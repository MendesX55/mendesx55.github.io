<!DOCTYPE html>

<html lang="en">
<head>
<meta content="yes" name="apple-mobile-web-app-capable"/>
<!-- This meta tag requests a black-translucent status bar. Behavior may vary by iOS version. -->
<meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/>
<link href="icon.png" rel="apple-touch-icon"/>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport"/>
<title>Tour Management - Sean Paul × Wiz Khalifa × DaBaby</title>
<style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Arial', sans-serif; background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460); color: #fff; min-height: 100vh; -webkit-user-select: none; -webkit-touch-callout: none; -webkit-tap-highlight-color: transparent; }
        .header { background: linear-gradient(90deg, #ff6b35, #f7931e, #ffd700); padding: 15px; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.3); position: sticky; top: 0; z-index: 100; }
        .header h1 { font-size: 1.6em; font-weight: bold; color: #000; text-shadow: 2px 2px 4px rgba(255,255,255,0.3); margin-bottom: 5px; }
        .artist-logos { display: flex; justify-content: center; gap: 10px; margin-top: 8px; }
        .logo-placeholder { width: 80px; height: 35px; background: linear-gradient(45deg, #000, #333); border-radius: 6px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 9px; color: #ffd700; border: 1px solid #ffd700; }
        .container { max-width: 430px; margin: 0 auto; height: calc(100vh - 120px); display: flex; flex-direction: column; }
        /* Tab navigation styles */
        .tab-navigation {
             display: flex;
             background: rgba(255,255,255,0.1);
             border-radius: 15px 15px 0 0;
             margin: 10px 10px 0 10px;
             overflow: hidden;
        }
        .tab-btn {
            flex: 1; /* Allow shrinking and growing */
            min-width: 0; /* Allow content to shrink below intrinsic size */
            padding: 8px;
            background: transparent;
            border: none;
            color: #ccc;
            font-weight: bold;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            line-height: 1.2;
            white-space: nowrap; /* Keep text from wrapping within the button */
            overflow: hidden; /* Hide overflowing text */
            text-overflow: ellipsis; /* Add ellipsis for overflowed text */
        }
        .tab-btn span { font-size: 1.5em; }
        .tab-btn.active { background: rgba(255,215,0,0.2); color: #ffd700; border-bottom: 3px solid #ffd700; }
        .tab-content { flex: 1; background: rgba(255,255,255,0.1); backdrop-filter: blur(10px); margin: 0 10px 10px 10px; border-radius: 0 0 15px 15px; padding: 15px; overflow-y: auto; display: none; }
        .tab-content.active { display: block; }
        .form-section { background: rgba(255,255,255,0.05); border-radius: 10px; padding: 15px; margin-bottom: 15px; border: 1px solid rgba(255,255,255,0.1); }
        .form-section h3 { color: #ffd700; margin-bottom: 12px; font-size: 1.1em; border-bottom: 1px solid rgba(255,215,0,0.3); padding-bottom: 5px; }
        .form-group { margin-bottom: 10px; }
        .form-group label { display: block; margin-bottom: 4px; color: #fff; font-weight: bold; font-size: 13px; }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 10px; border: none; border-radius: 6px; background: rgba(255,255,255,0.9); color: #000; font-size: 16px; -webkit-appearance: none; }
        .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .form-row-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        /* --- VISUAL FIX: Gas settings layout --- */
        .form-group-inline {
             display: grid; /* Use grid */
             grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); /* Responsive grid: minimum 110px, then share space */
             gap: 8px; /* Gap between items */
        }
         .form-group-inline .form-group {
             margin-bottom: 0; /* Remove bottom margin from grouped items */
         }
         .form-group-inline label {
             white-space: nowrap; /* Prevent label wrapping if space is tight */
         }
         /* Ensure inputs within inline groups still take full width of their container */
         .form-group-inline .form-group input {
            width: 100%;
         }
         /* --- End VISUAL FIX --- */

        .currency-input { position: relative; }
        .currency-prefix { position: absolute; left: 10px; top: 50%; transform: translateY(-50%); color: #666; font-weight: bold; pointer-events: none; z-index: 1; }
        .currency-input input { padding-left: 30px; }
        .btn { background: linear-gradient(45deg, #ff6b35, #f7931e); color: white; border: none; padding: 12px 20px; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 14px; transition: all 0.3s ease; margin: 5px 0; width: 100%; -webkit-tap-highlight-color: transparent; }
        .btn:active { transform: scale(0.98); }
        .btn-small { padding: 6px 12px; font-size: 11px; width: auto; }
        .btn-danger { background: linear-gradient(45deg, #e74c3c, #c0392b); }
        .route-item { background: rgba(255,255,255,0.05); border-radius: 8px; padding: 12px; margin-bottom: 10px; border-left: 4px solid #87CEEB; }
        .route-item.show-day { border-left-color: #ff6b35; }
        .route-item.cached { border-left-color: #4CAF50; }
        .route-item.error { border-left-color: #e74c3c; }
        .stats-grid { display: grid; gap: 8px; margin-bottom: 15px; }
        .stats-grid-2-col { grid-template-columns: 1fr 1fr; }
        .stats-grid-3-col { grid-template-columns: 1fr 1fr 1fr; }
        .stat-card { background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px; text-align: center; border: 1px solid rgba(255,255,255,0.1); }
        .stat-value { font-size: 1.2em; font-weight: bold; color: #ffd700; margin-bottom: 3px; }
        .stat-label { color: #ccc; font-size: 0.8em; }
        /* Clickable card styles */
        .venue-card, .hotel-card {
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            border-left: 4px solid #ffd700; /* Default Venue color */
            cursor: pointer; /* Indicate clickable */
            transition: all 0.3s ease;
        }
        /* Specific color for hotel cards */
        .hotel-card {
             border-left-color: #87CEEB; /* Hotel color */
        }
        .venue-card:hover, .hotel-card:hover { background: rgba(255,215,0,0.1); transform: translateY(-2px); }

        /* Expenses row style - adapted from table */
        .expense-row {
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            margin-bottom: 5px; /* Smaller margin for rows */
            padding: 8px 12px; /* Padding inside row */
            border-left: 4px solid #6A5ACD; /* Color for expenses */
            display: flex; /* Use flex for layout within row */
            justify-content: space-between; /* Space out content */
            align-items: center; /* Vertically align items */
            font-size: 0.9em;
            cursor: pointer; /* Indicate clickable for potential future editing */
        }
         .expense-row > div {
             flex: 1; /* Allow divs inside to grow/shrink */
             overflow: hidden; /* Hide overflow */
             text-overflow: ellipsis; /* Add ellipsis */
             white-space: nowrap; /* Prevent wrapping */
             padding-right: 5px; /* Add space between columns */
         }
        .expense-row .exp-date { flex-basis: 60px; flex-grow: 0; }
        .expense-row .exp-type { flex-basis: 50px; flex-grow: 0; }
        .expense-row .exp-loc { flex-basis: 80px; } /* Location can take more space */
        .expense-row .exp-usd,
        .expense-row .exp-cad { flex-basis: 50px; flex-grow: 0; text-align: right; }
         .expense-row .exp-actions { flex-basis: 30px; flex-grow: 0; padding-right: 0; text-align: right;} /* Actions column */


        .card-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 10px; margin-bottom: 8px; }
        .card-title { color: #ffd700; font-weight: bold; flex-grow: 1; word-break: break-word; }
        .card-date { font-weight: bold; color: #fff; white-space: nowrap; flex-shrink: 0; font-size: 11px; }
        .summary-box { background: #16213e; border: 1px solid rgba(255,215,0,0.3); border-radius: 8px; padding: 12px; margin-bottom: 15px; position: sticky; top: -15px; z-index: 10; }
        .day-summary-box { background: rgba(0,0,0,0.2); border: 1px solid rgba(255,215,0,0.2); border-radius: 8px; padding: 12px; margin-top: 20px; margin-bottom: 10px; }
        .day-summary-box h4 { color: #ffd700; text-align: center; margin-bottom: 10px; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); }
        .modal-content { background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460); margin: 10% auto; padding: 20px; border-radius: 15px; width: 90%; max-width: 400px; border: 1px solid rgba(255,215,0,0.3); max-height: 80vh; overflow-y: auto; }
        .modal-header { color: #ffd700; font-size: 1.3em; font-weight: bold; margin-bottom: 15px; border-bottom: 2px solid #ffd700; padding-bottom: 10px; display: flex; justify-content: space-between; align-items: center; }
        .modal-nav { background: none; border: none; color: #ffd700; font-size: 2em; cursor: pointer; padding: 0 10px; }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close:hover { color: #fff; }
        .route-selector { background: rgba(255,255,255,0.05); border-radius: 8px; padding: 15px; margin-bottom: 15px; }
        .route-selector h3 { display: flex; justify-content: space-between; align-items: center; cursor: pointer; }
        #route-builder-content.collapsed { display: none; }
        .toggle-arrow { font-size: 1.2em; transition: transform 0.3s ease; }
        .toggle-arrow.collapsed { transform: rotate(-90deg); }
        .route-controls-bottom { display: flex; gap: 10px; margin-top: 15px; margin-bottom: 15px; }
        .route-step { display: flex; align-items: center; margin-bottom: 10px; }
        .route-step-number { background: #ffd700; color: #000; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-weight: bold; margin-right: 10px; flex-shrink: 0; }
        .route-step select { flex-grow: 1; flex-shrink: 1; min-width: 0; padding: 8px; border-radius: 6px; border: none; background: rgba(255,255,255,0.9); color: #000; font-size: 16px; -webkit-appearance: none; }
        .progress-bar-container { position: relative; }
        .progress-bar { background: rgba(255,255,255,0.1); border-radius: 10px; height: 20px; margin: 10px 0; overflow: hidden; }
        .progress-fill { background: linear-gradient(90deg, #4CAF50, #8BC34A); height: 100%; width: 0%; transition: width 0.3s ease; border-radius: 10px; }
        .progress-text { position: absolute; width: 100%; text-align: center; line-height: 20px; font-size: 11px; font-weight: bold; color: #fff; top: 0; left: 0; }
        input[type="date"], input[type="time"], input[type="number"], select { height: 42px !important; font-size: 16px; padding: 10px; box-sizing: border-box; }
        .checkbox-group { display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; }
        .checkbox-item { display: flex; align-items: center; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 6px; }
        .checkbox-item input { width: 20px; height: 20px; margin-right: 10px; }
        /* Calendar Styles */
        #calendar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        #calendar-header button { background: #ff6b35; border: none; color: white; padding: 8px 12px; border-radius: 6px; cursor: pointer; }
        #month-year { font-size: 1.2em; font-weight: bold; }
        #calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px; }
        .calendar-day { background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); min-height: 80px; border-radius: 8px; padding: 5px; font-size: 0.8em; cursor: pointer; transition: background-color 0.3s; }
        .calendar-day:hover { background: rgba(255,215,0,0.2); }
        .calendar-day.other-month { background: rgba(0,0,0,0.1); color: #666; }
        .day-number { font-weight: bold; }
        /* Calendar day events/notes container */
        .day-events { font-size: 1.5em; line-height: 1; margin-top: 5px; display: flex; justify-content: center; } /* Center icons */
        .day-note { font-size: 9px; font-style: italic; color: #ccc; margin-top: 5px; text-align: center; }
</style>
</head>
<body>
<div style="padding: 10px 20px;">
<a href="index.html" style="text-decoration: none; color: #ff6b35; font-size: 1.5em;">← Back</a>
</div>
<div class="header">
<h1>🎤 TOUR MANAGER 🎤</h1>
<div class="artist-logos">
<div class="logo-placeholder">SEAN PAUL</div>
<div class="logo-placeholder">WIZ KHALIFA</div>
<div class="logo-placeholder">DABABY</div>
</div>
</div>
<div class="container">
<div class="tab-navigation">
<button class="tab-btn active" onclick="showTab('calendar')"><span>🗓️</span>CALENDAR</button>
<button class="tab-btn" onclick="showTab('venues')"><span>🎵</span>VENUES</button>
<button class="tab-btn" onclick="showTab('hotels')"><span>🏨</span>HOTELS</button>
<button class="tab-btn" onclick="showTab('routes')"><span>🚗</span>ROUTES</button>
<button class="tab-btn" onclick="showTab('expenses')"><span>💰</span>EXPENSES</button>
<button class="tab-btn" onclick="showTab('settings')"><span>⚙️</span>SETTINGS</button>
</div>
<!-- CALENDAR TAB -->
<div class="tab-content active" id="calendar">
<div id="calendar-header">
<button onclick="prevMonth()">◄ Prev</button>
<div id="month-year"></div>
<button onclick="nextMonth()">Next ►</button>
</div>
<div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px; text-align: center; font-weight: bold; color: #ffd700; font-size: 0.8em; padding-bottom: 5px;">
<div>SUN</div><div>MON</div><div>TUE</div><div>WED</div><div>THU</div><div>FRI</div><div>SAT</div>
</div>
<div id="calendar-grid"></div>
</div>
<!-- VENUES TAB -->
<div class="tab-content" id="venues">
<div class="summary-box">
<div class="stats-grid stats-grid-2-col">
<div class="stat-card"><div class="stat-value" id="venueCountStat">0</div><div class="stat-label">Total Shows</div></div>
<div class="stat-card"><div class="stat-value" id="venueSalesStat">$0</div><div class="stat-label">Total Sales (USD)</div></div>
</div>
</div>
<div id="venuesList"></div>
</div>
<!-- HOTELS TAB -->
<div class="tab-content" id="hotels">
<div class="summary-box">
<div class="stats-grid stats-grid-3-col">
<div class="stat-card"><div class="stat-value" id="hotelCountStat">0</div><div class="stat-label">Total Hotels</div></div>
<div class="stat-card"><div class="stat-value" id="hotelDaysStat">0</div><div class="stat-label">Total Days</div></div>
<div class="stat-card"><div class="stat-value" id="hotelCostStat">$0</div><div class="stat-label">Total Cost</div></div>
</div>
</div>
<div id="hotelsList"></div>
</div>
<!-- ROUTES TAB -->
<div class="tab-content" id="routes">
<div class="summary-box">
<div class="stats-grid stats-grid-3-col">
<div class="stat-card"><div class="stat-value" id="totalDistanceStat">0 km</div><div class="stat-label">Total Distance</div></div>
<div class="stat-card"><div class="stat-value" id="totalTimeStat">0h</div><div class="stat-label">Drive Time</div></div>
<div class="stat-card"><div class="stat-value" id="totalGasStat">$0</div><div class="stat-label">Est. Gas</div></div>
</div>
</div>
<div class="route-selector">
<h3 onclick="toggleRouteBuilder()">🗺️ Build Full Tour Itinerary <span class="toggle-arrow" id="routeBuilderToggleArrow">▼</span></h3>
<div id="route-builder-content">
<div id="routeSteps"><!-- Route steps will be generated by JS --></div>
<div class="route-controls-bottom"><button class="btn btn-small" onclick="addRouteStop()">+ Add Stop</button><button class="btn btn-small" onclick="removeRouteStop()">- Remove Stop</button><button class="btn btn-small" onclick="clearAllStops()">Clear All</button><button class="btn btn-small" onclick="autoFillRoute()">Auto-Fill</button></div>
</div>
<button class="btn" id="generateRouteBtn" onclick="generateCustomRoute()">🛣️ Generate Full Tour Route</button>
<div class="progress-bar-container" id="routeProgress" style="display: none;">
<div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
<div class="progress-text" id="progressText">Preparing...</div>
</div>
<div style="text-align: center; margin-top: 10px;"><span id="routeStopCount" style="color: #ffd700; font-size: 12px;">Stops: ${routeStopCounter} / Unlimited</span></div>
</div>
<div id="routeResults"></div>
</div>
<!-- EXPENSES TAB -->
<div class="tab-content" id="expenses">
<div class="summary-box">
<div class="stats-grid stats-grid-2-col">
<div class="stat-card"><div class="stat-value" id="expenseCountStat">0</div><div class="stat-label">Total Expenses</div></div>
<div class="stat-card"><div class="stat-value" id="expenseCostStat">$0</div><div class="stat-label">Total Cost</div></div>
</div>
</div>
<div id="expensesList"></div><!-- Expenses list will be populated here -->
</div>
<!-- SETTINGS (INPUT) TAB -->
<div class="tab-content" id="settings">
<div class="form-section"><h3>🏨 Hotel Confirmations</h3><div class="form-group"><label>Hotel Name</label><input id="hotelName" placeholder="Hotel name" type="text"/></div><div class="form-group"><label>Address</label><input id="hotelAddress" placeholder="Full address" type="text"/></div><div class="form-row"><div class="form-group"><label>Check-in</label><input id="checkinDate" type="date"/></div><div class="form-group"><label>Check-out</label><input id="checkoutDate" type="date"/></div></div><div class="form-row-2"><div class="form-group currency-input"><label>USD Cost</label><span class="currency-prefix">$</span><input id="hotelCostUSD" placeholder="0.00" step="0.01" type="number"/></div><div class="form-group currency-input"><label>Manual CAD</label><span class="currency-prefix">$</span><input id="hotelCostCAD" placeholder="0.00" step="0.01" type="number"/></div></div><div class="form-group"><label>Confirmation Notes</label><textarea id="hotelNotes" placeholder="Confirmation number, special requests, etc." rows="2"></textarea></div><button class="btn" onclick="addHotel()">Add Hotel</button></div>
<div class="form-section"><h3>🎵 Venue Information</h3><div class="form-group"><label>Venue Name</label><input id="venueName" placeholder="Venue name" type="text"/></div><div class="form-group"><label>Address</label><input id="venueAddress" placeholder="Full address" type="text"/></div><div class="form-row"><div class="form-group"><label>Show Date</label><input id="showDate" type="date"/></div><div class="form-group"><label>Show Time</label><input id="showTime" type="time"/></div></div><div class="form-row-3"><div class="form-group"><label>Start Inventory</label><input id="startInventory" placeholder="0" type="number"/></div><div class="form-group"><label>End Inventory</label><input id="endInventory" placeholder="0" type="number"/></div><div class="form-group currency-input"><label>Sales (USD)</label><span class="currency-prefix">$</span><input id="totalSales" placeholder="0.00" step="0.01" type="number"/></div></div><div class="form-group"><label>Venue Notes</textarea></div><button class="btn" onclick="addVenue()">Add Venue</button></div>
<div class="form-section"><h3>💰 Expenses</h3><div class="form-row"><div class="form-group"><label>Type</label><select id="expenseType"><option value="gas">Gas</option><option value="food">Food</option><option value="tolls">Tolls</option><option value="parking">Parking</option><option value="misc">Miscellaneous</option></select></div><div class="form-group"><label>Date</label><input id="expenseDate" type="date"/></div></div><div class="form-group"><label>Location</label><input id="expenseLocation" placeholder="Where was this expense?" type="text"/></div><div class="form-row-2"><div class="form-group currency-input"><label>USD Cost</label><span class="currency-prefix">$</span><input id="expenseAmountUSD" placeholder="0.00" step="0.01" type="number"/></div><div class="form-group currency-input"><label>Manual CAD</label><span class="currency-prefix">$</span><input id="expenseAmountCAD" placeholder="0.00" step="0.01" type="number"/></div></div><div class="form-group"><label>Notes</textarea></div><button class="btn" onclick="addExpense()">Add Expense</button></div>
<div class="form-section"><h3>📤 Export Data</h3><p style="font-size: 13px; color: #ccc; margin-bottom: 10px;">Select which data to include in your CSV file.</p>
<div class="checkbox-group">
<label class="checkbox-item"><input checked="" id="exportHotels" type="checkbox"/> Hotels</label>
<label class="checkbox-item"><input checked="" id="exportVenues" type="checkbox"/> Venues</label>
<label class="checkbox-item"><input checked="" id="exportExpenses" type="checkbox"/> Expenses</label>
<label class="checkbox-item"><input id="exportRoute" type="checkbox"/> Full Route Itinerary</label>
</div>
<button class="btn" onclick="exportTourData()">Export Selected Data to CSV</button>
</div>
<div class="form-section">
    <h3>⛽ Gas Settings</h3>
    <div class="form-group-inline"> <!-- Use the new class for inline layout -->
        <div class="form-group"><label for="kmPerLitre">Fuel KM/L:</label><input id="kmPerLitre" placeholder="e.g. 8" type="number" step="0.1"/></div>
        <div class="form-group"><label for="costPerLitre">Cost $/L:</label><input id="costPerLitre" placeholder="e.g. 1.75" type="number" step="0.01"/></div>
        <div class="form-group"><label for="heavyFootPercent">Go FAST %:</label><input id="heavyFootPercent" placeholder="e.g. 10" type="number" step="1"/></div>
    </div>
    <button class="btn" onclick="applySettings()">Apply Gas Settings</button>
</div>
<!-- Removed the Data Sync form-section -->
</div>
</div>
<!-- MODALS -->
<!-- Hotel Edit Modal -->
<div class="modal" id="hotelModal">
    <div class="modal-content">
        <div class="modal-header">
            <div>Edit Hotel Details</div>
            <span class="close" onclick="closeModal('hotelModal')">&times;</span>
        </div>
        <div id="hotelEditForm">
            <div class="form-group"><label for="editHotelName">Hotel Name</label><input id="editHotelName" type="text"/></div>
            <div class="form-group"><label for="editHotelAddress">Address</label><input id="editHotelAddress" type="text"/></div>
            <div class="form-row">
                <div class="form-group"><label for="editCheckinDate">Check-in</label><input id="editCheckinDate" type="date"/></div>
                <div class="form-group"><label for="editCheckoutDate">Check-out</label><input id="editCheckoutDate" type="date"/></div>
            </div>
            <div class="form-row-2">
                <div class="currency-input form-group"><label for="editHotelCostUSD">USD Cost</label><span class="currency-prefix">$</span><input id="editHotelCostUSD" step="0.01" type="number"/></div>
                <div class="currency-input form-group"><label for="editHotelCostCAD">Manual CAD</label><span class="currency-prefix">$</span><input id="editHotelCostCAD" step="0.01" type="number"/></div>
            </div>
            <div class="form-group"><label for="editHotelNotes">Confirmation Notes</label><textarea id="editHotelNotes" rows="3"></textarea></div>
            <button class="btn" onclick="saveHotelEdit()">Save Changes</button>
            <button class="btn btn-danger" onclick="deleteHotel()">Delete Hotel</button>
        </div>
    </div>
</div>

<!-- Venue Edit Modal -->
<div class="modal" id="venueModal">
    <div class="modal-content">
        <div class="modal-header">
            <div>Edit Venue Details</div>
            <span class="close" onclick="closeModal('venueModal')">&times;</span>
        </div>
        <div id="venueEditForm">
            <div class="form-group"><label for="editVenueName">Venue Name</label><input id="editVenueName" type="text"/></div>
            <div class="form-group"><label for="editVenueAddress">Address</label><input id="editVenueAddress" type="text"/></div>
            <div class="form-row">
                <div class="form-group"><label for="editShowDate">Show Date</label><input id="editShowDate" type="date"/></div>
                <div class="form-group"><label for="editShowTime">Show Time</label><input id="editShowTime" type="time"/></div>
            </div>
            <div class="form-row-3">
                <div class="form-group"><label for="editStartInventory">Start Inventory</label><input id="editStartInventory" type="number"/></div>
                <div class="form-group"><label for="editEndInventory">End Inventory</label><input id="editEndInventory" type="number"/></div>
                <div class="form-group currency-input"><label for="editTotalSales">Sales (USD)</label><span class="currency-prefix">$</span><input id="editTotalSales" step="0.01" type="number"/></div>
            </div>
            <div class="form-group"><label for="editVenueNotes">Venue Notes</textarea></div>
            <button class="btn" onclick="saveVenueEdit()">Save Changes</button>
            <button class="btn btn-danger" onclick="deleteVenue()">Delete Venue</button>
        </div>
    </div>
</div>

<!-- Calendar Day Details Modal -->
<div class="modal" id="calendarModal"><div class="modal-content" id="calendarModalContent"></div></div>


<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>

<script>
    // Tour name and localStorage keys
    const TOUR_NAME = "seanpaul";
    // Key used for current storage (local and Firebase)
    const CURRENT_LOCAL_STORAGE_KEY = `tourData_${TOUR_NAME}`;
    // Key used in older versions (before tourData_seanpaul)
    // const OLD_LOCAL_STORAGE_KEY = `tourData`; // Removed as per user request


    // Firebase Configuration
    // Using the API key from your original code snippet, confirmed as correct.
    const firebaseConfig = {
      apiKey: "AIzaSyDk14v_vZFteu3J3ltcs5jXu03AiVqZUZc",
      authDomain: "tour-manager-b2888.firebaseapp.com",
      projectId: "tour-manager-b2888",
      // measurementId: "G-XXXXXXXXXX", // Add if you have it
      // storageBucket: "YOUR_STORAGE_BUCKET", // Add if you use it
      // messagingSenderId: "YOUR_MESSAGING_SENDER_ID", // Add if you use it
      // appId: "YOUR_APP_ID", // Add if you use it
    };

    // Initialize Firebase
    let firebaseApp;
    let db; // Firestore database instance
    try {
        firebaseApp = firebase.initializeApp(firebaseConfig);
        db = firebaseApp.firestore();
        console.log("Firebase initialized.");
        // Optional: Enable offline persistence
        // firebase.firestore().enablePersistence()
        //   .then(() => console.log("Offline persistence enabled"))
        //   .catch((err) => {
        //       if (err.code == 'failed-precondition') {
        //           console.warn('Persistence failed: Multiple tabs open.');
        //       } else if (err.code == 'unimplemented') {
        //            console.warn('Persistence not supported.');
        //       } else {
        //           console.error("Persistence failed:", err);
        //       }
        //   });
    } catch (error) {
        console.error("Firebase initialization failed:", error);
        db = null; // Ensure db is null if init fails
    }

    // Global tour data object - initialized with defaults
    let tourData = {
        hotels: [],
        venues: [],
        expenses: [],
        routePlannerState: [],
        routeCache: {},
        settings: { kmPerLitre: 8.5, costPerLitre: 1.75, heavyFootPercent: 10 } // Default settings
    };

    let currentEditId = null; // Used for modals
    let routeStopCounter = 0; // Counter for route planner steps in the UI
    let isGeneratingRoute = false;
    let currentMonth = new Date().getMonth();
    let currentYear = new Date().getFullYear();
    let currentModalDate = null; // Used for calendar day modal navigation

    // Helper functions
    function formatDate(dateString) { if (!dateString) return ''; const date = new Date(dateString + 'T00:00:00'); const day = String(date.getDate()).padStart(2, '0'); const month = String(date.getMonth() + 1).padStart(2, '0'); return `${day}-${month}`; }
    function formatTime(timeString) { if (!timeString) return ''; let [hours, minutes] = timeString.split(':'); const ampm = hours >= 12 ? 'PM' : 'AM'; hours = hours % 12 || 12; return `${hours}:${minutes} ${ampm}`; }

     // Improved getLocationDetails to handle missing IDs gracefully
    function getLocationDetails(locationId) {
         if (!locationId) return { type: 'Unknown', name: 'N/A', address: 'N/A', id: null };
        const [type, id] = locationId.split(':');
         if (!type || !id) return { type: 'Unknown', name: 'N/A', address: 'N/A', id: null };

        const numId = parseInt(id);
        if (type === 'Hotel') {
            const hotel = tourData.hotels.find(h => h.id === numId);
            return hotel ? { ...hotel, type: 'Hotel' } : { type: 'Hotel', name: `Hotel ${id}`, address: 'N/A', id: numId }; // Use ID in fallback name
        } else if (type === 'Venue') {
            const venue = tourData.venues.find(v => v.id === numId);
            return venue ? { ...venue, type: 'Venue' } : { type: 'Venue', name: `Venue ${id}`, address: 'N/A', id: numId }; // Use ID in fallback name
        }
         return { type: 'Unknown', name: `ID ${id}`, address: 'N/A', id: numId }; // Generic fallback
     }


    // --- Data Loading & Saving ---

    // Save data to localStorage and Firebase
    async function saveData() {
        try {
            // Ensure settings are numeric before saving
            if (tourData.settings) {
                tourData.settings.kmPerLitre = parseFloat(tourData.settings.kmPerLitre) || 0;
                tourData.settings.costPerLitre = parseFloat(tourData.settings.costPerLitre) || 0;
                tourData.settings.heavyFootPercent = parseFloat(tourData.settings.heavyFootPercent) || 0;
            } else {
                 tourData.settings = { kmPerLitre: 8.5, costPerLitre: 1.75, heavyFootPercent: 10 }; // Ensure settings object exists with defaults
            }
             // Ensure core arrays and objects exist
            if (!Array.isArray(tourData.hotels)) tourData.hotels = [];
            if (!Array.isArray(tourData.venues)) tourData.venues = [];
            if (!Array.isArray(tourData.expenses)) tourData.expenses = [];
            if (!Array.isArray(tourData.routePlannerState)) tourData.routePlannerState = [];
            if (tourData.routeCache === null || typeof tourData.routeCache !== 'object') tourData.routeCache = {};


            // Save to the CURRENT local storage key
            localStorage.setItem(CURRENT_LOCAL_STORAGE_KEY, JSON.stringify(tourData));
            console.log("Data saved to localStorage:", CURRENT_LOCAL_STORAGE_KEY);

            if (db) {
                // Use the CURRENT_LOCAL_STORAGE_KEY for the Firebase document ID
                await db.collection("tourData").doc(CURRENT_LOCAL_STORAGE_KEY).set(tourData);
                console.log("Data synced to Firebase:", CURRENT_LOCAL_STORAGE_KEY);
            }
        } catch (e) {
            console.error("Failed to save data:", e);
        }
    }

    // Load data from Firebase or localStorage on init
    async function loadData() {
        let loadedData = null;
        let source = 'default'; // Track where data was loaded from

        // 1. Attempt to load from Firebase (primary source) using the current key
        if (db) {
            try {
                const doc = await db.collection("tourData").doc(CURRENT_LOCAL_STORAGE_KEY).get();
                if (doc.exists) {
                    loadedData = doc.data();
                    source = 'firebase';
                    console.log("Data loaded from Firebase.");
                } else {
                    console.log("No data found in Firebase for tour key:", CURRENT_LOCAL_STORAGE_KEY);
                }
            } catch (e) {
                console.error("Failed to load data from Firebase:", e);
                 // Continue to local storage if Firebase load fails
            }
        }

        // 2. If Firebase didn't have data, attempt to load from CURRENT localStorage key (fallback)
        if (!loadedData) {
            const currentLocalDataString = localStorage.getItem(CURRENT_LOCAL_STORAGE_KEY);
             if (currentLocalDataString) {
                try {
                    const parsedCurrentData = JSON.parse(currentLocalDataString);
                     // Basic check if it looks like actual data
                    if (parsedCurrentData && (parsedCurrentData.hotels?.length > 0 || parsedCurrentData.venues?.length > 0 || parsedCurrentData.expenses?.length > 0 || parsedCurrentData.routePlannerState?.length > 0 || (parsedCurrentData.routeCache && Object.keys(parsedCurrentData.routeCache).length > 0))) {
                        loadedData = parsedCurrentData;
                        source = 'current_localStorage';
                        console.log("Data loaded from CURRENT localStorage key:", CURRENT_LOCAL_STORAGE_KEY);
                    } else {
                         console.log("CURRENT localStorage key found, but seems empty or invalid.");
                    }
                } catch (e) {
                     console.error("Failed to parse data from CURRENT localStorage key:", CURRENT_LOCAL_STORAGE_KEY, e);
                     loadedData = null; // Ensure loadedData is null if parsing fails
                }
            } else {
                console.log("No data found in CURRENT localStorage key:", CURRENT_LOCAL_STORAGE_KEY);
            }
        }


        // 3. Update global tourData and ensure structure/types
        if (loadedData) {
             // Merge loaded data with default structure
            tourData = {
                ...{ hotels: [], venues: [], expenses: [], routePlannerState: [], routeCache: {}, settings: { kmPerLitre: 8.5, costPerLitre: 1.75, heavyFootPercent: 10 } },
                ...loadedData
            };
        } else {
             // No data found anywhere, use default tourData initialized globally
             console.log("No saved data found anywhere. Starting with default tourData.");
        }

        // Ensure core arrays and objects exist and settings are numeric after loading/merging
        if (!Array.isArray(tourData.hotels)) tourData.hotels = [];
        if (!Array.isArray(tourData.venues)) tourData.venues = [];
        if (!Array.isArray(tourData.expenses)) tourData.expenses = [];
        if (!Array.isArray(tourData.routePlannerState)) tourData.routePlannerState = [];
        if (tourData.routeCache === null || typeof tourData.routeCache !== 'object') tourData.routeCache = {};

         if (tourData.settings) {
            tourData.settings.kmPerLitre = parseFloat(tourData.settings.kmPerLitre) || 0;
            tourData.settings.costPerLitre = parseFloat(tourData.settings.costPerLitre) || 0;
            tourData.settings.heavyFootPercent = parseFloat(tourData.settings.heavyFootPercent) || 0;
        } else {
             tourData.settings = { kmPerLitre: 8.5, costPerLitre: 1.75, heavyFootPercent: 10 }; // Ensure settings object exists with defaults
        }


        // If data was loaded from local storage and Firebase was initially empty,
        // save it now to Firebase for future use.
         if (source !== 'firebase' && loadedData && db) {
              console.log("Loaded from local, syncing to Firebase...");
               db.collection("tourData").doc(CURRENT_LOCAL_STORAGE_KEY).set(tourData)
                 .then(() => console.log("Local data synced to Firebase."))
                 .catch(e => console.error("Failed to sync local data to Firebase:", e));
         }


        // Initialize UI elements based on loaded data
        loadRoutePlannerState(); // This rebuilds route planner UI and calls updateAllDisplays
        populateSettingsForm(); // Load settings into the form inputs
        // updateAllDisplays(); // Called by loadRoutePlannerState

         // Initial tab display - ensures correct display state after load
        showTab('calendar'); // Start on calendar tab
    }

    // Removed uploadLocalToFirebase function as per user request.
    // The saveData function handles syncing to Firebase automatically on every change now.


    // --- Gas Calculation Logic ---

    function calculateGasCost(distanceInMeters) {
        // Use default settings if tourData.settings is missing or values are invalid
        const settings = tourData.settings || {};
        const kmPerLitre = parseFloat(settings.kmPerLitre);
        const costPerLitre = parseFloat(settings.costPerLitre);
        const heavyFootPercent = parseFloat(settings.heavyFootPercent);

        // Basic validation - if essential settings are missing or invalid, return 0
        if (isNaN(kmPerLitre) || kmPerLitre <= 0 || isNaN(costPerLitre) || costPerLitre <= 0) {
             return 0;
        }

        const distanceInKm = distanceInMeters / 1000;
        const litresNeeded = distanceInKm / kmPerLitre;
        let estimatedCost = litresNeeded * costPerLitre;

        if (!isNaN(heavyFootPercent) && heavyFootPercent > 0) {
            estimatedCost *= (1 + heavyFootPercent / 100);
        }

        return estimatedCost;
    }

    // --- Settings ---

    function populateSettingsForm() {
         const settings = tourData.settings || {}; // Use default if tourData.settings is null/undefined
         document.getElementById('kmPerLitre').value = settings.kmPerLitre ?? '';
         document.getElementById('costPerLitre').value = settings.costPerLitre ?? '';
         document.getElementById('heavyFootPercent').value = settings.heavyFootPercent ?? '';
    }

    function applySettings() {
        const kmPerLitreInput = document.getElementById("kmPerLitre").value;
        const costPerLitreInput = document.getElementById("costPerLitre").value;
        const heavyFootPercentInput = document.getElementById("heavyFootPercent").value;

        // Ensure settings object exists
        if (!tourData.settings) tourData.settings = {};

        // Store as number, default to 0 if invalid input but save even if 0
        tourData.settings.kmPerLitre = parseFloat(kmPerLitreInput) || 0;
        tourData.settings.costPerLitre = parseFloat(costPerLitreInput) || 0;
        tourData.settings.heavyFootPercent = parseFloat(heavyFootPercentInput) || 0;

        saveData(); // Save the updated settings (includes Firebase sync)
        alert("Settings applied and saved.");

        // Re-render route displays to reflect new gas costs immediately
        // Only do this if the Routes tab is currently active for efficiency
        if (document.getElementById('routes').classList.contains('active')) {
            renderRouteResults(); // Re-render existing cached routes with updated gas costs
            updateRouteSummaryStats(); // Update the total stats with updated gas costs
        }
         // Gas costs on other tabs (Expenses, Calendar) are recalculated on display refresh anyway
    }


    // --- Initial Load ---
    window.onload = async function() {
        // Firebase is initialized before this function runs (globally in <script>)
        await loadData(); // Load data first (from Firebase or localStorage)

        // Set expense date default
        document.getElementById('expenseDate').value = new Date().toISOString().split('T')[0];

        // Add event listeners for forms to auto-save on change
        // These listeners are added AFTER data is loaded, so initial load doesn't trigger saves
        document.querySelectorAll(".form-section input, .form-section select, .form-section textarea").forEach(el => {
             el.addEventListener("change", saveData); // Now saves to LS and Firebase
        });


        // Add listeners for USD inputs to show approx CAD
        document.getElementById('hotelCostUSD').addEventListener('input', function() { const cadInput = document.getElementById('hotelCostCAD'); if (cadInput) { cadInput.placeholder = this.value ? `≈ ${(parseFloat(this.value) * 1.35).toFixed(2)} CAD` : '0.00'; } });
        document.getElementById('expenseAmountUSD').addEventListener('input', function() { const cadInput = document.getElementById('expenseAmountCAD'); if (cadInput) { cadInput.placeholder = this.value ? `≈ ${(parseFloat(this.value) * 1.35).toFixed(2)} CAD` : '0.00'; } });


        // Initial tab display is handled by loadData -> loadRoutePlannerState -> updateAllDisplays -> showTab('calendar')
    };


    // --- Tab Navigation and Display Updates ---

    function showTab(tabName) {
        document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
        document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
        const activeTabContent = document.getElementById(tabName);
         if (activeTabContent) {
             activeTabContent.classList.add('active');
         } else {
             console.error(`Tab content not found for tab: ${tabName}`);
             return; // Stop if tab content doesn't exist
         }
        const activeButton = document.querySelector(`.tab-btn[onclick*="'${tabName}'"]`);
        if (activeButton) activeButton.classList.add('active');

        // Update displays specific to tabs when shown
        // These functions now render based on the current state of tourData, which is loaded on init
        if (tabName === 'calendar') renderCalendar();
        else if (tabName === 'venues') updateVenuesDisplay(); // This will now attach click listeners
        else if (tabName === 'hotels') updateHotelsDisplay(); // This will now attach click listeners
        else if (tabName === 'routes') {
            updateRouteSelects(); // Ensure dropdowns are populated
            renderRouteResults(); // Render cached results with current settings
            updateRouteSummaryStats(); // Update total stats with current settings
        }
        else if (tabName === 'expenses') updateExpensesDisplay(); // This will now attach click listeners
         else if (tabName === 'settings') populateSettingsForm(); // Ensure settings form shows current values
    }

    // Called from various places to refresh UI elements
    function updateAllDisplays() {
        // These functions now rely on tourData object and render based on its current state
        updateHotelsDisplay(); // Will attach event listeners
        updateExpensesDisplay(); // Will attach event listeners
        updateVenuesDisplay(); // Will attach event listeners
        updateRouteSelects(); // This one only updates the dropdowns, not the results view
        // Route results and summary are updated when the 'routes' tab is shown
        // or when settings are applied via renderRouteResults() and updateRouteSummaryStats()
        renderCalendar(); // Calendar needs to reflect venues/hotels/travel days
    }

    // --- Data Entry Functions ---
    // addHotel, addVenue, addExpense, clearHotelForm, clearVenueForm, clearExpenseForm
    // remain largely the same, using element.value and pushing to tourData arrays.
    // Validation added to addHotel/addVenue/saveHotelEdit/saveVenueEdit.

     function addHotel() {
        const nameInput = document.getElementById('hotelName').value.trim();
        const addressInput = document.getElementById('hotelAddress').value.trim();
        const checkinInput = document.getElementById('checkinDate').value;
        const checkoutInput = document.getElementById('checkoutDate').value;
        const usdCost = parseFloat(document.getElementById('hotelCostUSD').value) || 0;
        const cadCost = parseFloat(document.getElementById('hotelCostCAD').value) || 0;
        const notesInput = document.getElementById('hotelNotes').value.trim();

        if (!nameInput || !addressInput || !checkinInput) {
             alert('Please fill in hotel name, full address, and check-in date');
             return;
        }
         // Basic date validation
        if (checkoutInput && new Date(checkinInput) > new Date(checkoutInput)) {
             alert('Check-out date cannot be before check-in date.');
             return;
        }

        const hotel = {
             id: Date.now(), // Unique ID
             name: nameInput,
             address: addressInput,
             checkin: checkinInput,
             checkout: checkoutInput,
             costUSD: usdCost,
             costCAD: cadCost,
             notes: notesInput,
             type: 'hotel' // Identifier for lookups (lowercase for consistency)
        };

        tourData.hotels.push(hotel);
        saveData(); // Save changes
        updateHotelsDisplay(); // Refresh UI for hotels tab
        updateRouteSelects(); // Update route planner selects if this hotel is added
        renderCalendar(); // Refresh calendar to show new hotel stays
        clearHotelForm();
        alert('Hotel added successfully!');
     }

     function addVenue() {
        const nameInput = document.getElementById('venueName').value.trim();
        const addressInput = document.getElementById('venueAddress').value.trim();
        const dateInput = document.getElementById('showDate').value;
        const timeInput = document.getElementById('showTime').value;
        const startInventory = parseInt(document.getElementById('startInventory').value) || 0;
        const endInventory = parseInt(document.getElementById('endInventory').value) || 0;
        const totalSales = parseFloat(document.getElementById('totalSales').value) || 0;
        const notesInput = document.getElementById('venueNotes').value.trim();

        if (!nameInput || !addressInput || !dateInput) {
             alert('Please fill in venue name, full address, and show date');
             return;
        }

        const venue = {
             id: Date.now(), // Unique ID
             name: nameInput,
             address: addressInput,
             date: dateInput,
             time: timeInput,
             startInventory: startInventory,
             endInventory: endInventory,
             totalSales: totalSales,
             notes: notesInput,
             type: 'venue' // Identifier for lookups (lowercase)
        };

        tourData.venues.push(venue);
        saveData(); // Save changes
        updateVenuesDisplay(); // Refresh UI for venues tab
         updateRouteSelects(); // Update route planner selects if this venue is added
        renderCalendar(); // Refresh calendar to show new shows
        clearVenueForm();
        alert('Venue added successfully!');
     }

     function addExpense() {
        const typeInput = document.getElementById('expenseType').value;
        const dateInput = document.getElementById('expenseDate').value;
        const locationInput = document.getElementById('expenseLocation').value.trim();
        const usdAmount = parseFloat(document.getElementById('expenseAmountUSD').value) || 0;
        const cadAmount = parseFloat(document.getElementById('expenseAmountCAD').value) || 0;
        const notesInput = document.getElementById('expenseNotes').value.trim();

        if (!dateInput || (usdAmount <= 0 && cadAmount <= 0)) {
             alert('Please enter date and an amount (USD or Manual CAD).');
             return;
        }

        const expense = {
             id: Date.now(), // Unique ID
             type: typeInput,
             date: dateInput,
             location: locationInput,
             amountUSD: usdAmount,
             amountCAD: cadAmount,
             notes: notesInput,
             category: 'expense' // Identifier (lowercase) - used for display functions
        };

        tourData.expenses.push(expense);
        saveData(); // Save changes
        updateExpensesDisplay(); // Refresh UI for expenses tab
        clearExpenseForm();
        alert('Expense added successfully!');
     }


    // Delete function (used by delete buttons)
    function deleteItem(type, id) {
        if (confirm(`Are you sure you want to delete this ${type}?`)) {
            if (type === 'hotel') {
                tourData.hotels = tourData.hotels.filter(h => h.id !== id);
                 // Also remove this hotel from route planner if it's used
                 tourData.routePlannerState = tourData.routePlannerState.map(stop =>
                     stop.selectValue === `Hotel:${id}` ? { selectValue: '', dateValue: stop.dateValue } : stop
                 ).filter(stop => stop.selectValue !== ''); // Remove empty stops resulting from deletion if desired
                 if (tourData.routePlannerState.length === 0) tourData.routePlannerState = [{ selectValue: '', dateValue: '' }]; // Ensure at least one empty stop

                updateHotelsDisplay(); // Refresh display
                 updateRouteSelects(); // Update dropdowns
                 renderCalendar(); // Refresh calendar
                 // Re-render route results if currently visible, as deleted stop might affect them
                 if (document.getElementById('routes').classList.contains('active')) {
                     renderRouteResults();
                     updateRouteSummaryStats();
                 }
            } else if (type === 'venue') {
                tourData.venues = tourData.venues.filter(v => v.id !== id);
                 // Also remove this venue from route planner if it's used
                 tourData.routePlannerState = tourData.routePlannerState.map(stop =>
                     stop.selectValue === `Venue:${id}` ? { selectValue: '', dateValue: stop.dateValue } : stop
                 ).filter(stop => stop.selectValue !== ''); // Remove empty stops resulting from deletion if desired
                 if (tourData.routePlannerState.length === 0) tourData.routePlannerState = [{ selectValue: '', dateValue: '' }]; // Ensure at least one empty stop

                updateVenuesDisplay(); // Refresh display
                 updateRouteSelects(); // Update dropdowns
                 renderCalendar(); // Refresh calendar
                 // Re-render route results if currently visible
                  if (document.getElementById('routes').classList.contains('active')) {
                     renderRouteResults();
                     updateRouteSummaryStats();
                 }
            } else if (type === 'expense') {
                tourData.expenses = tourData.expenses.filter(e => e.id !== id);
                updateExpensesDisplay(); // Refresh display
            }
            saveData(); // Save changes after filtering
        }
    }

     function clearHotelForm() { ['hotelName', 'hotelAddress', 'checkinDate', 'checkoutDate', 'hotelCostUSD', 'hotelCostCAD', 'hotelNotes'].forEach(id => document.getElementById(id).value = ''); document.getElementById('hotelCostCAD').placeholder = '0.00'; }
    function clearVenueForm() { ['venueName', 'venueAddress', 'showDate', 'showTime', 'startInventory', 'endInventory', 'totalSales', 'venueNotes'].forEach(id => document.getElementById(id).value = ''); }
    function clearExpenseForm() { ['expenseAmountUSD', 'expenseAmountCAD', 'expenseLocation', 'expenseNotes'].forEach(id => document.getElementById(id).value = ''); document.getElementById('expenseDate').value = new Date().toISOString().split('T')[0]; document.getElementById('expenseAmountCAD').placeholder = '0.00';}


    // --- Route Builder Logic ---
    // saveRoutePlannerState, loadRoutePlannerState, updateStopCounter,
    // addRouteStop, removeRouteStop, clearAllStops, autoFillRoute,
    // updateRouteSelects, toggleRouteBuilder, generateCustomRoute,
    // renderDayRouteSequence, renderRouteResults, updateRouteSummaryStats, renderErrorDay
    // remain largely the same, with minor refinements for robustness (e.g., checking array types).


    function saveRoutePlannerState() {
        tourData.routePlannerState = Array.from({ length: routeStopCounter }, (_, i) => {
            const select = document.getElementById(`routeSelect${i}`);
            const date = document.getElementById(`routeDate${i}`);
            return { selectValue: select ? select.value : '', dateValue: date ? date.value : '' };
        });
        saveData(); // Now saves to LS and Firebase
    }
    function loadRoutePlannerState() {
        const routeStepsContainer = document.getElementById('routeSteps');
        routeStepsContainer.innerHTML = '';
        // Ensure routePlannerState is an array, default to empty if null/undefined
        if (!Array.isArray(tourData.routePlannerState)) {
             tourData.routePlannerState = [];
        }
        // Ensure there's at least one stop initially if the loaded state is empty
        if (tourData.routePlannerState.length === 0) {
            tourData.routePlannerState = [{ selectValue: '', dateValue: '' }];
        }

        // Add stops based on the loaded/migrated routePlannerState
        routeStopCounter = 0; // Reset counter before adding
        // Loop through the loaded state and add UI elements for each stop
        tourData.routePlannerState.forEach((stopState, index) => {
             const newIndex = routeStopCounter; // Use routeStopCounter as the current index
             const newStep = document.createElement('div');
             newStep.className = 'route-step';
             newStep.id = `routeStep${newIndex}`;
             newStep.innerHTML = `<div class="route-step-number">${newIndex + 1}</div><select id="routeSelect${newIndex}"><option value="">-- Select Stop --</option></select><input type="date" id="routeDate${newIndex}" style="margin-left: 10px; width: 120px; padding: 4px; font-size: 12px; flex-shrink: 0;">`;
             routeStepsContainer.appendChild(newStep);
             routeStopCounter++;

              // Add event listeners to the newly created elements
              const selectEl = document.getElementById(`routeSelect${newIndex}`);
              const dateEl = document.getElementById(`routeDate${newIndex}`);
              if(selectEl) selectEl.addEventListener('change', saveRoutePlannerState);
              if(dateEl) dateEl.addEventListener('change', saveRoutePlannerState);

              // Populate the select and set date from the loaded state *for this specific step*
              // This population logic is now handled primarily by updateRouteSelects after the loop
        });


        updateStopCounter();
         // After creating all stop elements, populate all selects with options and ensure correct values are set
         // updateRouteSelects also sets the date values
        updateRouteSelects();
        // Initial display update
        // updateAllDisplays(); // Called by updateRouteSelects -> saveData -> updateAllDisplays
    }


    function updateStopCounter() { document.getElementById('routeStopCount').textContent = `Stops: ${routeStopCounter} / Unlimited`; }

    function addRouteStop(shouldSave = true) {
        const routeStepsContainer = document.getElementById('routeSteps');
        const newIndex = routeStopCounter;
        const newStep = document.createElement('div');
        newStep.className = 'route-step';
        newStep.id = `routeStep${newIndex}`;
        // InnerHTML contains the select and date input
        newStep.innerHTML = `<div class="route-step-number">${newIndex + 1}</div><select id="routeSelect${newIndex}"><option value="">-- Select Stop --</option></select><input type="date" id="routeDate${newIndex}" style="margin-left: 10px; width: 120px; padding: 4px; font-size: 12px; flex-shrink: 0;">`;
        routeStepsContainer.appendChild(newStep);
        routeStopCounter++;
        updateStopCounter();

         // Add event listeners AFTER the elements are appended
         const selectEl = document.getElementById(`routeSelect${newIndex}`);
         const dateEl = document.getElementById(`routeDate${newIndex}`);
         if(selectEl) selectEl.addEventListener('change', saveRoutePlannerState);
         if(dateEl) dateEl.addEventListener('change', saveRoutePlannerState);


        // Add a new empty state entry for this stop if it doesn't exist
        // This handles cases where add is called directly vs via load
        if (tourData.routePlannerState.length <= newIndex) {
             tourData.routePlannerState[newIndex] = { selectValue: '', dateValue: '' };
        } else {
             // If it already exists (e.g., from loaded data), reset it? Or keep it?
             // Assuming add means add a NEW empty stop at the end.
             tourData.routePlannerState.push({ selectValue: '', dateValue: '' });
        }


         updateRouteSelects(); // Update all selects (including the new one) with options and set values

        if (shouldSave) { saveData(); } // Save the updated state
        // updateAllDisplays is called by showTab or loadData, which should handle the final render sync
    }


    function removeRouteStop() {
        if (routeStopCounter <= 1) return;
        const lastStep = document.getElementById('routeSteps').lastElementChild;
        if (lastStep) {
            lastStep.remove();
            routeStopCounter--;
            updateStopCounter();
            // Remove the last entry from the routePlannerState array
             tourData.routePlannerState.pop();
            saveRoutePlannerState(); // Save the state after removing
            // No need to updateAllDisplays here, saveRoutePlannerState handles persistence,
            // and the UI element is removed directly.
        }
    }

    function clearAllStops() {
        if (confirm('Are you sure you want to clear all route stops and cached route data? This cannot be undone!')) {
            tourData.routePlannerState = [];
            tourData.routeCache = {}; // Also clear cache on full route clear
            saveData(); // Now saves to LS and Firebase
            loadRoutePlannerState(); // Resets to a single empty stop and updates display
            document.getElementById('routeResults').innerHTML = ''; // Clear displayed results
            updateRouteSummaryStats(); // Reset route summary stats
        }
    }

    function autoFillRoute() {
        if (!confirm('This will replace your current route plan with one auto-filled from all hotels and venues, sorted by date. Continue?')) return;

        tourData.routePlannerState = [];
        const allStops = [];
        tourData.hotels.forEach(h => { if (h.checkin) allStops.push({ date: h.checkin, stopId: `Hotel:${h.id}`, sortKey: new Date(h.checkin).getTime() }); });
        tourData.venues.forEach(v => { if (v.date) allStops.push({ date: v.date, stopId: `Venue:${v.id}`, sortKey: new Date(v.date).getTime() + 1 }); }); // Add 1ms to venue date to sort after hotel on same day
        allStops.sort((a, b) => a.sortKey - b.sortKey);
        tourData.routePlannerState = allStops.map(stop => ({ selectValue: stop.stopId, dateValue: stop.date }));
         if (tourData.routePlannerState.length === 0) tourData.routePlannerState.push({ selectValue: '', dateValue: '' }); // Ensure at least one stop
        saveData(); // Now saves to LS and Firebase
        loadRoutePlannerState(); // Reloads the UI for the planner state and updates displays
        alert(`Auto-filled ${allStops.length} stops!`);
    }

     // Updates the options and selected values in all route planner selects
    function updateRouteSelects() {
        const allLocations = [...tourData.hotels.map(h => ({ id: h.id, name: h.name, type: 'Hotel' })), ...tourData.venues.map(v => ({ id: v.id, name: v.name, type: 'Venue' }))];
        for (let i = 0; i < routeStopCounter; i++) {
            const select = document.getElementById(`routeSelect${i}`);
            const dateInput = document.getElementById(`routeDate${i}`);

            if (select) {
                // Store the current selection and date value before clearing options
                 const currentSelectValue = select.value;
                 const currentDateValue = dateInput ? dateInput.value : '';

                let placeholderText = (i === 0) ? '-- Select Starting Point --' : '-- Select Next Stop --';
                select.innerHTML = `<option value="">${placeholderText}</option>`; // Clear existing options and add placeholder

                // Add options for all locations
                allLocations.forEach(location => {
                    const option = document.createElement('option');
                    option.value = `${location.type}:${location.id}`;
                    option.textContent = `${location.type}: ${location.name}`;
                    select.appendChild(option);
                });

                 // Try to restore the previous value, falling back to tourData.routePlannerState
                 // Ensure tourData.routePlannerState[i] exists
                 if (!tourData.routePlannerState[i]) {
                      console.warn(`routePlannerState missing entry for index ${i} during select update. Creating placeholder.`);
                      tourData.routePlannerState[i] = { selectValue: '', dateValue: '' };
                 }

                 if (currentSelectValue && select.querySelector(`option[value="${currentSelectValue}"]`)) {
                      select.value = currentSelectValue;
                 } else if (tourData.routePlannerState[i].selectValue && select.querySelector(`option[value="${tourData.routePlannerState[i].selectValue}"]`)) {
                     // Check if the value from state is still a valid option before setting
                      select.value = tourData.routePlannerState[i].selectValue;
                 } else {
                      // If the saved value is no longer a valid option, reset the state value
                      tourData.routePlannerState[i].selectValue = '';
                 }


                 // Try to restore the previous date value, falling back to tourData.routePlannerState
                 if (dateInput) {
                      if (currentDateValue) {
                         dateInput.value = currentDateValue;
                      } else if (tourData.routePlannerState[i].dateValue) {
                          dateInput.value = tourData.routePlannerState[i].dateValue;
                      }
                      // Ensure state reflects UI after potential restoration or clearing
                      tourData.routePlannerState[i].dateValue = dateInput.value;
                 } else {
                      // If date input doesn't exist, ensure state is clear for date value
                       tourData.routePlannerState[i].dateValue = '';
                 }

                 // Ensure the tourData.routePlannerState reflects the final UI values after refresh
                 // This step might be redundant if the logic above is correct, but adds robustness.
                 tourData.routePlannerState[i].selectValue = select ? select.value : '';
                 if (dateInput) tourData.routePlannerState[i].dateValue = dateInput.value;


            } else {
                 // If select element doesn't exist for this index, ensure state is cleared or handled
                 if (tourData.routePlannerState[i]) {
                      tourData.routePlannerState[i].selectValue = '';
                      tourData.routePlannerState[i].dateValue = '';
                 }
            }
        }
        saveRoutePlannerState(); // Save the state after updating selects and dates
    }


    function toggleRouteBuilder() {
        const content = document.getElementById('route-builder-content');
        const arrow = document.getElementById('routeBuilderToggleArrow');
        content.classList.toggle('collapsed');
        arrow.classList.toggle('collapsed');
    }

    async function generateCustomRoute() {
        if (isGeneratingRoute) { alert('Route generation is already in progress...'); return; }
        isGeneratingRoute = true;

        const generateBtn = document.getElementById('generateRouteBtn');
        const progressDiv = document.getElementById('routeProgress');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const routeResults = document.getElementById('routeResults');

        generateBtn.disabled = true;
        generateBtn.textContent = '🔄 Generating...';
        progressDiv.style.display = 'block';
        routeResults.innerHTML = ''; // Clear previous results before generating
        progressText.textContent = 'Preparing route...';
        progressFill.style.width = '0%';

        tourData.routeCache = {}; // Clear existing cache before generating new

        try {
            const plannedSegments = [];
            // Build segments from the route planner state
            for (let i = 0; i < tourData.routePlannerState.length - 1; i++) {
                const fromStopInfo = tourData.routePlannerState[i];
                const toStopInfo = tourData.routePlannerState[i + 1];
                // A segment is valid only if both start and end stops are selected
                if (!fromStopInfo || !fromStopInfo.selectValue || !toStopInfo || !toStopInfo.selectValue) {
                     console.warn(`Skipping incomplete segment at planner index ${i}: Missing stop selection.`);
                    continue;
                 }
                // A segment is considered to "start" on the date specified for its *start* stop
                 if (!fromStopInfo.dateValue) {
                      console.warn(`Segment at planner index ${i} missing start date. Using 'No Date'.`);
                 }


                const fromLocation = getLocationDetails(fromStopInfo.selectValue);
                const toLocation = getLocationDetails(toStopInfo.selectValue);

                 // A segment is routable only if both stops have valid addresses
                 if(fromLocation && fromLocation.address && fromLocation.address !== 'N/A' && toLocation && toLocation.address && toLocation.address !== 'N/A') {
                     plannedSegments.push({
                         date: fromStopInfo.dateValue || 'No Date', // Use date of the start stop, or 'No Date'
                         from: fromLocation,
                         to: toLocation,
                         // Include original IDs for potential future use, though not strictly needed for current rendering/caching
                         fromStopId: fromStopInfo.selectValue,
                         toStopId: toStopInfo.selectValue,
                         plannerIndex: i // Keep track of its original index in the planner state
                     });
                 } else {
                     // Handle invalid addresses - render an error later
                     console.warn(`Skipping segment at planner index ${i} due to invalid address: ${fromLocation.name} -> ${toLocation.name}`);
                     // Still add a placeholder segment to display an error
                      plannedSegments.push({
                          date: fromStopInfo.dateValue || 'No Date',
                          from: fromLocation, // Still include partial info
                          to: toLocation,
                          fromStopId: fromStopInfo.selectValue,
                          toStopId: toStopInfo.selectValue,
                          plannerIndex: i,
                          hasError: true,
                          errorMessage: `Invalid address: ${fromLocation.address === 'N/A' ? fromLocation.name : ''} ${toLocation.address === 'N/A' ? toLocation.name : ''}`.trim()
                      });
                 }
            }

            if (plannedSegments.length === 0) {
                throw new Error('No valid route segments found with selected stops in the planner.');
            }

            // Group *consecutive* planned segments by date they START on to form route "sequences" for API calls.
            const sequencesForGeneration = [];
             let currentSequence = null;

            plannedSegments.forEach((segment, index) => {
                 // Skip segments marked with errors for API generation
                 if (segment.hasError) {
                      // Render error for this specific segment instead of trying to group
                       renderErrorDay(segment.date, sequencesForGeneration.length + 1, `Cannot route: ${segment.errorMessage}`);
                      return; // Skip this segment in grouping
                 }

                 const prevSequence = currentSequence; // Keep track of the last built sequence
                 const isNewDate = !prevSequence || segment.date !== prevSequence.date;
                 // Check if this segment's start stop matches the end stop of the *last segment added to the current sequence*
                 const isConsecutiveStopInSequence = prevSequence && prevSequence.stops && prevSequence.stops.length > 0 && segment.from.id === prevSequence.stops[prevSequence.stops.length - 1].id;


                if (!prevSequence || isNewDate || !isConsecutiveStopInSequence) {
                    // Start a new sequence if it's the very first segment processed (and not an error),
                    // OR if it's a new date,
                    // OR if the stops are not consecutive with the end of the previous sequence.
                    currentSequence = {
                        date: segment.date, // Date the sequence starts on
                        stops: [segment.from, segment.to], // Sequence of stops for this API call
                        plannedSegments: [segment] // Planned segments included in this sequence
                    };
                     sequencesForGeneration.push(currentSequence);
                } else {
                    // Add segment to the current sequence if the stops link up and it's the same date.
                    // Only add the 'to' stop to the sequence list (the 'from' is already the last stop).
                    currentSequence.stops.push(segment.to);
                    currentSequence.plannedSegments.push(segment);
                }
            });


            if (sequencesForGeneration.length === 0) {
                 // This might happen if ALL planned segments had invalid addresses
                 if (plannedSegments.length > 0 && plannedSegments.every(s => s.hasError)) {
                      // All planned segments had errors, messages already rendered
                       progressText.textContent = '❌ Generation failed (all segments had errors)';
                       setTimeout(() => { progressDiv.style.display = 'none'; }, 3000);
                       return; // Stop processing
                 }
                 throw new Error('No routable sequences found after processing planned segments.');
            }

            let processedSequences = 0;
             // Determine the total number of sequences to process for progress tracking
             const totalSequencesToProcess = sequencesForGeneration.length;


             routeResults.innerHTML = '<h3 style="color: #ffd700; margin-bottom: 15px;">🛣️ Generated Route</h3>'; // Add main header
             // Re-render any error segments first
             plannedSegments.filter(s => s.hasError).forEach((segment, index) => {
                 // Render errors here first, sequenceCounter might not be reliable yet
                 routeResults.innerHTML += `<div class="route-item error"><strong>Segment starting ${formatDate(segment.date)} (${getLocationDetails(segment.fromStopId).name} → ${getLocationDetails(segment.toStopId).name}):</strong> ${segment.errorMessage}</div>`;
             });


            // Process each sequence
            for (const sequence of sequencesForGeneration) {

                 // Address validation for generation was done during segment building, skipping here.

                try {
                    // Cache key includes the date and the sequence of all addresses for this specific sequence
                    const cacheKey = `${sequence.date}_${sequence.stops.map(s => s.address).join('|')}`;
                     const CACHE_TTL = 7200000; // 2 hours in milliseconds

                    let sequenceRouteData;

                    if (tourData.routeCache[cacheKey] && (Date.now() - tourData.routeCache[cacheKey].timestamp < CACHE_TTL)) {
                        sequenceRouteData = tourData.routeCache[cacheKey].data;
                        sequenceRouteData.isCached = true;
                        console.log(`Cache hit for sequence key: ${cacheKey}`);
                    } else {
                         console.log(`Cache miss for sequence key: ${cacheKey}. Fetching from API.`);
                        // Construct origin, destination, and waypoints for API from the sequence stops
                        const origin = sequence.stops[0].address;
                        const destination = sequence.stops[sequence.stops.length - 1].address;
                        const waypoints = sequence.stops.slice(1, -1).map(loc => loc.address).join('|'); // All intermediate stops are waypoints

                         // Using the proxy URL
                        const url = `https://maps-proxy-hru8.onrender.com/maps?origin=${encodeURIComponent(origin)}&destination=${encodeURIComponent(destination)}&waypoints=${encodeURIComponent(waypoints)}`;

                        const response = await fetch(url);
                        if (!response.ok) {
                             // Attempt to read error body if available
                            const errorBody = await response.text();
                            throw new Error(`API Load failed (status: ${response.status}) for sequence starting ${sequence.date}. Response: ${errorBody}`);
                        }
                        const data = await response.json();

                        if (data.status !== 'OK') {
                             // Include Google Maps error message if available
                             const googleErrorMessage = data.status === 'ZERO_RESULTS' ? 'No route found. Check addresses.' : data.error_message || 'Unknown API error.';
                            throw new Error(`Google Maps Error for sequence starting ${sequence.date}: ${data.status}. ${googleErrorMessage}`);
                        }
                         if (!data.routes || data.routes.length === 0 || !data.routes[0].legs || data.routes[0].legs.length === 0) {
                             throw new Error(`API returned OK but no route/legs found for sequence starting ${sequence.date}.`);
                         }


                        // Store minimal data in cache + stops info needed for rendering
                         // Store the actual stops (with name/type/address/id) that were used
                        sequenceRouteData = {
                            legs: data.routes[0].legs, // Stores distance, duration, start/end addresses per leg
                            stops: sequence.stops, // Store the sequence of stop details
                            totalDistance: data.routes[0].legs.reduce((sum, leg) => sum + leg.distance.value, 0),
                            totalTime: data.routes[0].legs.reduce((sum, leg) => sum + (leg.duration_in_traffic || leg.duration).value, 0),
                             // DO NOT store totalGas here, it's calculated dynamically on render/summary
                            isCached: false
                        };

                        // Update cache
                        tourData.routeCache[cacheKey] = { data: sequenceRouteData, timestamp: Date.now() };
                        saveData(); // Save the updated cache
                    }

                    // Render this sequence's route
                    renderRouteSequence(sequence.date, sequenceRouteData, processedSequences + 1); // Pass the sequence start date and data


                } catch (sequenceError) { // This catch block handles errors for a single sequence API call/processing
                    console.error(`Error processing sequence starting ${sequence.date}:`, sequenceError);
                     renderErrorDay(sequence.date, processedSequences + 1, `Error processing sequence: ${sequenceError.message}`);
                }
                processedSequences++; // Increment counter after processing EACH sequence
                const progress = (processedSequences / totalSequencesToProcess) * 100;
                progressFill.style.width = `${progress}%`;
                progressText.textContent = `Sequence ${processedSequences}/${totalSequencesToProcess} processed...`;
                await new Promise(resolve => setTimeout(resolve, 50)); // Small delay between sequences

            } // End sequence loop


             // After all sequences are processed, update the overall total stats
             updateRouteSummaryStats();

            progressText.textContent = '✅ Route generation completed!';

        } catch (error) { // This catch block handles overall errors (e.g., no valid routable sequences found at all)
            console.error('Overall Route generation error:', error);
            routeResults.innerHTML += `<div class="route-item error"><strong>❌ Overall Route Generation Error:</strong> ${error.message}</div>`; // Append overall error
            progressText.textContent = '❌ Generation failed';
        } finally {
            isGeneratingRoute = false;
            generateBtn.disabled = false;
            generateBtn.textContent = '🛣️ Generate Full Tour Route';
            // Keep progress bar visible briefly to show completion/failure
            setTimeout(() => { progressDiv.style.display = 'none'; }, 3000);
        }
    }


    // Renders a single cached route *sequence*
    // date: The date the sequence starts on (from cache key)
    // sequenceData: The data from the cache for this sequence
    // sequenceCounter: The Nth sequence being rendered (for display in header)
    function renderRouteSequence(date, sequenceData, sequenceCounter) {
        const routeResults = document.getElementById('routeResults');
        // Ensure sequenceData structure is valid
         if (!sequenceData || !Array.isArray(sequenceData.legs) || !Array.isArray(sequenceData.stops) || sequenceData.legs.length === 0 || sequenceData.stops.length < 2) {
             console.warn("Attempted to render invalid sequence data:", sequenceData);
             return; // Do not render invalid data
         }


        const sequenceHours = Math.floor(sequenceData.totalTime / 3600);
        const sequenceMinutes = Math.floor((sequenceData.totalTime % 3600) / 60);

        // Calculate total gas for the sequence dynamically using current settings
        let sequenceTotalGas = 0;
        sequenceData.legs.forEach(leg => {
           sequenceTotalGas += calculateGasCost(leg.distance.value);
        });

        // Display a summary for this specific sequence
        const sequenceSummary = document.createElement('div');
        sequenceSummary.className = 'day-summary-box'; // Re-using day-summary style for sequences
        sequenceSummary.innerHTML = `<h4>Route Sequence ${sequenceCounter} (${date === 'No Date' ? 'No Date' : formatDate(date)}) ${sequenceData.isCached ? '✓' : '✅'}</h4>
                                     <div class="stats-grid stats-grid-3-col">
                                         <div class="stat-card"><div class="stat-value">${(sequenceData.totalDistance/1000).toFixed(0)} km</div><div class="stat-label">Seq. Distance</div></div>
                                         <div class="stat-card"><div class="stat-value">${sequenceHours}h ${sequenceMinutes}m</div><div class="stat-label">Seq. Drive Time</div></div>
                                         <div class="stat-card"><div class="stat-value">$${sequenceTotalGas.toFixed(0)}</div><div class="stat-label">Est. Gas</div></div>
                                     </div>`;
        routeResults.appendChild(sequenceSummary);

        // Render each leg within this sequence
        sequenceData.legs.forEach((leg, index) => {
            // Calculate gas cost for the segment dynamically
            const gasCost = calculateGasCost(leg.distance.value);
            // Get the correct 'from' and 'to' stop for this leg from the cached 'stops' array for THIS sequence
            const fromStop = sequenceData.stops[index] || { name: 'Unknown From', type: 'Unknown' }; // Fallback
            const toStop = sequenceData.stops[index + 1] || { name: 'Unknown To', type: 'Unknown' }; // Fallback

            const routeSegment = document.createElement('div');
            // Add 'show-day' class if the *end* of this segment (leg) is a Venue
            routeSegment.className = `route-item ${sequenceData.isCached ? 'cached' : ''} ${toStop.type === 'Venue' ? 'show-day' : ''}`;
            routeSegment.innerHTML = `<div class="route-header"><strong>${fromStop.name} → ${toStop.name}</strong></div>
                                     <div class="route-info">
                                         <strong>Distance:</strong> ${leg.distance.text} | <strong>Time (traffic):</strong> ${(leg.duration_in_traffic || leg.duration).text}<br>
                                         <strong>Est. Gas:</strong> $${gasCost.toFixed(0)} CAD
                                     </div>`;
            routeResults.appendChild(routeSegment);
        });
    }


    // Re-render the route results displayed on the page based on current tourData.routeCache
    function renderRouteResults() {
         const routeResults = document.getElementById('routeResults');
         routeResults.innerHTML = ''; // Clear current display
         if (!tourData.routeCache || Object.keys(tourData.routeCache).length === 0) {
             routeResults.innerHTML = '<p style="text-align: center; color: #ccc;">Generate a route using the planner above.</p>';
             return;
         }

         routeResults.innerHTML = '<h3 style="color: #ffd700; margin-bottom: 15px;">🛣️ Generated Route</h3>'; // Add main header

         // Sort cache keys by date (the start date of the sequence)
         const sortedCacheKeys = Object.keys(tourData.routeCache).sort();
         let sequenceCounter = 0;

         sortedCacheKeys.forEach(key => {
             const cacheEntry = tourData.routeCache[key];
             // Ensure the cache entry structure is valid
             if (!cacheEntry || !cacheEntry.data || !Array.isArray(cacheEntry.data.legs) || !Array.isArray(cacheEntry.data.stops) || cacheEntry.data.legs.length === 0 || cacheEntry.data.stops.length < 2) {
                  console.warn(`Skipping invalid or empty cache entry for rendering: ${key}`, cacheEntry);
                  // Optionally render an error message for this specific key
                  // routeResults.innerHTML += `<div class="route-item error">Invalid cache data for key: ${key}</div>`;
                  return; // Skip this invalid entry
             }

             const sequenceData = cacheEntry.data;
             const date = key.split('_')[0]; // Extract date from the cache key (which is the sequence start date)
             sequenceCounter++; // Increment counter for each sequence rendered

             // Use the renderRouteSequence function to display this cached sequence
             renderRouteSequence(date, sequenceData, sequenceCounter); // Pass sequenceCounter

         });
    }

    // Update the overall route summary stats (Total Distance, Time, Gas)
    function updateRouteSummaryStats() {
        let grandTotalDistanceMeters = 0;
        let grandTotalTimeSecs = 0;
        let grandTotalGas = 0;

        // Ensure routeCache exists and is an object
        if (!tourData.routeCache || typeof tourData.routeCache !== 'object') {
            tourData.routeCache = {}; // Reset if invalid
        }

        // Iterate through ALL cached sequences to sum totals
        Object.values(tourData.routeCache).forEach(cacheEntry => {
            // Ensure cache entry is valid before processing
             if (!cacheEntry || !cacheEntry.data || !Array.isArray(cacheEntry.data.legs)) {
                  console.warn(`Skipping invalid cache entry in stats:`, cacheEntry);
                  return; // Skip this invalid entry
             }
            const sequenceData = cacheEntry.data;
             // Sum distances and times directly from cached values
            grandTotalDistanceMeters += sequenceData.totalDistance || 0;
            grandTotalTimeSecs += sequenceData.totalTime || 0;
             // Sum gas costs per leg dynamically using current settings
            sequenceData.legs.forEach(leg => {
                grandTotalGas += calculateGasCost(leg.distance.value);
            });
        });

        const totalHours = Math.floor(grandTotalTimeSecs / 3600);
        const totalMinutes = Math.floor((grandTotalTimeSecs % 3600) / 60);

        document.getElementById('totalDistanceStat').textContent = `${(grandTotalDistanceMeters/1000).toFixed(0)} km`;
        document.getElementById('totalTimeStat').textContent = `${totalHours}h ${totalMinutes}m`;
        document.getElementById('totalGasStat').textContent = '$' + grandTotalGas.toFixed(0);
    }


    function renderErrorDay(date, sequenceCounter, errorMessage) { // Renamed from renderErrorDay to clarify it's per sequence
        const routeResults = document.getElementById('routeResults');
        const errorSummary = document.createElement('div');
        errorSummary.className = 'day-summary-box'; // Use day-summary style
        errorSummary.style.borderColor = '#e74c3c';
        // Display the date and a specific error message for clarity
        errorSummary.innerHTML = `<h4>Route Sequence ${sequenceCounter} (${date === 'No Date' ? 'No Date' : formatDate(date)}) ❌</h4><div class="route-item error"><strong>Error:</strong> ${errorMessage}</div>`;
        routeResults.appendChild(errorSummary);
    }


    // --- Calendar Logic ---
     function renderCalendar() {
        const calendarEl = document.getElementById('calendar-grid');
        const monthYearEl = document.getElementById('month-year');
        if (!calendarEl || !monthYearEl) return;
        calendarEl.innerHTML = '';
        const firstDay = new Date(currentYear, currentMonth, 1).getDay(); // 0 = Sunday, 6 = Saturday
        const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
        const daysInPrevMonth = new Date(currentYear, currentMonth, 0).getDate();

        monthYearEl.textContent = `${new Date(currentYear, currentMonth).toLocaleString('default', { month: 'long' })} ${currentYear}`;

        // Add days from previous month to fill the first week
        for (let i = firstDay - 1; i >= 0; i--) {
             const prevMonthDay = daysInPrevMonth - i;
             const prevMonthDate = new Date(currentYear, currentMonth - 1, prevMonthDay);
             const dateStr = prevMonthDate.toISOString().split('T')[0];
             // Use other-month class and add click handler for potential month navigation
              calendarEl.innerHTML += `<div class="calendar-day other-month" onclick="showDayDetails('${dateStr}')"><div class="day-number">${prevMonthDay}</div></div>`;
        }

        // Add days for the current month
        for (let day = 1; day <= daysInMonth; day++) {
            const dateStr = `${currentYear}-${String(currentMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
            let dayHtml = `<div class="calendar-day" onclick="showDayDetails('${dateStr}')"><div class="day-number">${day}</div>`;

            const events = getEventsForDate(dateStr);
            let eventIcons = '';

            // --- CALENDAR ICON LOGIC (Priority: Venue > Travel > None) ---
            if (events.isVenue) {
                 eventIcons = '🎵';
            } else if (events.isTravel) {
                 eventIcons = '🚗';
            }
            // Don't show hotel icon if it's *just* a hotel stay day based on new requirement

            dayHtml += `<div class="day-events">${eventIcons}</div>`;

            // Add static notes (adjust dates as needed)
            if (dateStr === '2025-07-08') dayHtml += `<div class="day-note">🎂 My Birthday!</div>`;
            if (dateStr === '2025-07-16') dayHtml += `<div class="day-note">Break at Home</div>`;

            // Add check-in/check-out notes ONLY if it's a hotel stay and NOT a venue/travel day
             if (events.isHotelStay && !events.isVenue && !events.isTravel) {
                  const hotel = tourData.hotels.find(h => dateStr === h.checkin || dateStr === h.checkout);
                  if (hotel) {
                       if (dateStr === hotel.checkin && dateStr === hotel.checkout) dayHtml += `<div class="day-note">${hotel.name} (Day Use?)</div>`;
                       else if (dateStr === hotel.checkin) dayHtml += `<div class="day-note">${hotel.name} (Check-in)</div>`;
                       else if (dateStr === hotel.checkout) dayHtml += `<div class="day-note">${hotel.name} (Check-out)</div>`;
                  }
             } else if (!events.isVenue && !events.isTravel && !events.isHotelStay && day % 10 === 0) {
                 // Add the "Keep it up!" note only on days with no other events/icons/hotel notes
                 dayHtml += `<div class="day-note">Keep it up!</div>`;
             }


            dayHtml += '</div>';
            calendarEl.innerHTML += dayHtml;
        }

         // Add days from next month to fill the grid
        const totalDaysDisplayed = calendarEl.children.length; // Count the elements already added
        const remainingSlots = 42 - totalDaysDisplayed; // Max slots needed for 6 full weeks
        if (remainingSlots > 0) {
             for (let i = 1; i <= remainingSlots; i++) {
                const nextMonthDate = new Date(currentYear, currentMonth + 1, i);
                const dateStr = nextMonthDate.toISOString().split('T')[0];
                 // Use other-month class and add click handler
                 calendarEl.innerHTML += `<div class="calendar-day other-month" onclick="showDayDetails('${dateStr}')"><div class="day-number">${i}</div></div>`;
             }
        }
    }

     // Determines what kind of events happen on a given date (for calendar icon logic)
     function getEventsForDate(dateStr) {
         let isVenue = tourData.venues.some(v => v.date === dateStr);
         let isHotelStay = tourData.hotels.some(h => {
              // Check if dateStr is between checkin and checkout (inclusive)
             if (h.checkin && h.checkout) {
                 const checkin = new Date(h.checkin + 'T00:00:00');
                 const checkout = new Date(h.checkout + 'T00:00:00');
                 const currentDate = new Date(dateStr + 'T00:00:00');
                 return currentDate >= checkin && currentDate <= checkout;
             }
             return false;
         });

         // Check route planner & cache for travel days
         let isTravel = false;

         // A day is a travel day if its date is the *start date* of any cached route sequence with legs
         Object.keys(tourData.routeCache).forEach(key => {
              const cacheDayStartDateStr = key.split('_')[0];
              // Ensure cache entry and data are valid and represent a route
               const cacheEntry = tourData.routeCache[key];
               if (cacheDayStartDateStr === dateStr && cacheEntry && cacheEntry.data && Array.isArray(cacheEntry.data.legs) && cacheEntry.data.legs.length > 0) {
                    isTravel = true;
               }
         });

          // Also consider days that fall *within* the range of any cached multi-day route sequence
         Object.keys(tourData.routeCache).forEach(key => {
              const cacheDayStartDateStr = key.split('_')[0];
              // Ensure cache entry and data are valid
              if (!tourData.routeCache[key] || !tourData.routeCache[key].data || !Array.isArray(tourData.routeCache[key].data.stops) || tourData.routeCache[key].data.stops.length < 2) {
                   return; // Skip invalid cache entry
              }
              const sequenceData = tourData.routeCache[key].data;

              // Find the date for the LAST stop in the cached sequence (by looking up the stop ID in planner state)
              // Note: This assumes the last stop's ID is present in the planner state and has a date.
               let cacheDayEndDateStr = null;
               if (Array.isArray(tourData.routePlannerState)) { // Ensure plannerState is an array
                    const lastStopInSequence = sequenceData.stops[sequenceData.stops.length - 1];
                    const lastStopId = lastStopInSequence.type + ':' + lastStopInSequence.id; // Build ID string
                    const lastStopPlannerEntry = tourData.routePlannerState.find(r => r.selectValue === lastStopId);
                    if (lastStopPlannerEntry && lastStopPlannerEntry.dateValue) {
                        cacheDayEndDateStr = lastStopPlannerEntry.dateValue;
                    }
               }


              if (cacheDayStartDateStr && cacheDayEndDateStr && cacheDayStartDateStr !== cacheDayEndDateStr) {
                   const cacheStart = new Date(cacheDayStartDateStr + 'T00:00:00');
                   const cacheEnd = new Date(cacheDayEndDateStr + 'T00:00:00');
                   const current = new Date(dateStr + 'T00:00:00');

                   // If the current date is strictly between the cache start and end dates (non-inclusive of start, inclusive of end)
                   if (current > cacheStart && current <= cacheEnd) {
                       isTravel = true; // It's an intermediate or end travel day covered by cache
                   }
              }
         });

        return { isVenue, isHotelStay, isTravel }; // Return combined info
    }


    // Shows modal with details for a specific date
    function showDayDetails(dateStr) {
        const modal = document.getElementById('calendarModal');
        const content = document.getElementById('calendarModalContent');

        const venuesOnDay = tourData.venues.filter(v => v.date === dateStr);
        const hotelsOnDay = tourData.hotels.filter(h => {
             if (h.checkin && h.checkout) {
                 const checkin = new Date(h.checkin + 'T00:00:00');
                 const checkout = new Date(h.checkout + 'T00:00:00');
                 const currentDate = new Date(dateStr + 'T00:00:00');
                 return currentDate >= checkin && currentDate <= checkout;
             }
             return false;
        });

        let html = `<div class="modal-header">
                        <button class="modal-nav prev" onclick="showPrevDay()">◄</button>
                        <div>Details for ${formatDate(dateStr)}</div>
                        <button class="modal-nav next" onclick="showNextDay()">►</button>
                        <span class="close" onclick="closeModal('calendarModal')">&times;</span>
                    </div>`;

        if (venuesOnDay.length > 0) { html += `<h3>🎵 Venues</h3>` + venuesOnDay.map(v => `<div class="route-item venue-card" style="cursor:default; border-left-color:#ffd700;">${v.name} @ ${formatTime(v.time)}<br><small>${v.address ? v.address.substring(0, 50) + (v.address.length > 50 ? '...' : '') : 'N/A'}</small></div>`).join(''); }
        if (hotelsOnDay.length > 0) { html += `<h3>🏨 Hotels</h3>` + hotelsOnDay.map(h => `<div class="route-item hotel-card" style="cursor:default; border-left-color:#87CEEB;">${h.name}<br><small>Check-in: ${formatDate(h.checkin)} | Check-out: ${formatDate(h.checkout)}</small></div>`).join(''); }


        // Find cached route data sequences that *include* this date as part of their sequence range.
         const relevantCachedSequenceKeys = Object.keys(tourData.routeCache).filter(key => {
            const cacheDayStartDateStr = key.split('_')[0];
            // Ensure cache entry and data are valid
            if (!tourData.routeCache[key] || !tourData.routeCache[key].data || !Array.isArray(tourData.routeCache[key].data.legs) || !Array.isArray(tourData.routeCache[key].data.stops) || tourData.routeCache[key].data.legs.length === 0 || tourData.routeCache[key].data.stops.length < 2) {
                 return false; // Skip invalid cache entry
            }
             const sequenceData = tourData.routeCache[key].data;

            // Find the date for the LAST stop in the cached sequence (by looking up the stop ID in planner state)
             let cacheDayEndDateStr = null;
              if (Array.isArray(tourData.routePlannerState)) { // Ensure plannerState is an array
                 const lastStopInSequence = sequenceData.stops[sequenceData.stops.length - 1];
                 const lastStopId = lastStopInSequence.type + ':' + lastStopInSequence.id;
                 const lastStopPlannerEntry = tourData.routePlannerState.find(r => r.selectValue === lastStopId);
                 if (lastStopPlannerEntry && lastStopPlannerEntry.dateValue) {
                     cacheDayEndDateStr = lastStopPlannerEntry.dateValue;
                 }
            }


             if (cacheDayStartDateStr && cacheDayEndDateStr) {
                 const cacheStart = new Date(cacheDayStartDateStr + 'T00:00:00');
                 const cacheEnd = new Date(cacheDayEndDateStr + 'T00:00:00');
                 const current = new Date(dateStr + 'T00:00:00');

                 // Check if the current date is within the range [cacheStart, cacheEnd] inclusive
                 return current >= cacheStart && current <= cacheEnd;
             }
             return false; // Cannot determine range if dates are missing
        }).sort(); // Sort keys to display routes in chronological order by start date

        if (relevantCachedSequenceKeys.length > 0) {
             html += `<h3>🚗 Travel Information</h3>`; // General header for travel info on this date

             relevantCachedSequenceKeys.forEach((key, index) => {
                 const cacheEntry = tourData.routeCache[key];
                 const sequenceData = cacheEntry.data; // Already checked for validity in filter
                 const cacheDayStartDateStr = key.split('_')[0];

                 const sequenceHours = Math.floor(sequenceData.totalTime / 3600);
                 const sequenceMinutes = Math.floor((sequenceData.totalTime % 3600) / 60);
                 const sequenceTotalGas = calculateGasCost(sequenceData.totalDistance); // Dynamic gas calc

                  // Display a summary for this specific sequence
                  // Use index + 1 as the sequence counter within the modal list for this day
                  html += `<h4>Route Sequence ${index + 1} Starting ${formatDate(cacheDayStartDateStr)} (${sequenceData.isCached ? 'Cached' : 'Real-time'})</h4>
                         <div class="day-summary-box" style="margin-top:0;">
                            <div class="stats-grid stats-grid-3-col" style="margin-bottom:0;">
                                <div class="stat-card"><div class="stat-value">${(sequenceData.totalDistance/1000).toFixed(0)} km</div><div class="stat-label">Seq. Distance</div></div>
                                <div class="stat-card"><div class="stat-value">${sequenceHours}h ${sequenceMinutes}m</div><div class="stat-label">Seq. Drive Time</div></div>
                                <div class="stat-card"><div class="stat-value">$${sequenceTotalGas.toFixed(0)}</div><div class="stat-label">Est. Gas</div></div>
                            </div>
                         </div>
                         <h4>Segments for this Route Sequence</h4>`; // Changed to Segments as it lists legs


                   // Display segments (legs) from the cached sequence data
                   sequenceData.legs.forEach((leg, legIndex) => {
                        const gasCost = calculateGasCost(leg.distance.value); // Dynamic gas calc
                        const fromStop = sequenceData.stops[legIndex] || { name: 'Unknown From', type: 'Unknown' };
                        const toStop = sequenceData.stops[legIndex + 1] || { name: 'Unknown To', type: 'Unknown' };
                         html += `<div class="route-item" style="border-left-color:${sequenceData.isCached ? '#4CAF50' : '#87CEEB'};">
                                     <strong>${fromStop.name} → ${toStop.name}</strong>
                                     <br><small>Distance: ${leg.distance.text} | Time: ${(leg.duration_in_traffic || leg.duration).text} | Est. Gas: $${gasCost.toFixed(0)}</small>
                                     </div>`;
                    });
             });

        }


        // Check if any events were displayed
        const hasEvents = venuesOnDay.length > 0 || hotelsOnDay.length > 0 || relevantCachedSequenceKeys.length > 0;
         if (!hasEvents) {
             html += `<p style="text-align:center; padding: 20px;">No events scheduled for this day.</p>`;
        }


        content.innerHTML = html;
        modal.style.display = 'block';
        currentModalDate = dateStr;
        addSwipeListeners(modal);
    }


    function showPrevDay() {
        if (!currentModalDate) return;
        let date = new Date(currentModalDate + 'T12:00:00Z'); // Use midday to avoid timezone issues with date arithmetic
        date.setDate(date.getDate() - 1);
        showDayDetails(date.toISOString().split('T')[0]);
    }

    function showNextDay() {
        if (!currentModalDate) return;
        let date = new Date(currentModalDate + 'T12:00:00Z'); // Use midday
        date.setDate(date.getDate() + 1);
        showDayDetails(date.toISOString().split('T')[0]);
    }

    let touchstartX = 0;
    let touchendX = 0;
    function handleSwipe() {
         // Allow swipe only if the modal content itself is NOT scrollable
         const modalContentEl = document.getElementById('calendarModalContent');
         // Check if the modal content height exceeds its container height (allowing scroll)
         const isContentScrollable = modalContentEl.scrollHeight > modalContentEl.clientHeight;

         if (!isContentScrollable) {
            if (touchendX < touchstartX - 50) showNextDay();
            if (touchendX > touchstartX + 50) showPrevDay();
         } else {
             // If content is scrollable, regular touch/scroll behavior is expected.
         }
     }

    function addSwipeListeners(element) {
        // Ensure listeners are not duplicated by removing them first
        const handleTouchStart = (e) => { touchstartX = e.changedTouches[0].screenX; };
        const handleTouchEnd = (e) => { touchendX = e.changedTouches[0].screenX; handleSwipe(); };

        // Removing and re-adding ensures only one set of listeners is active when modal is shown
        element.removeEventListener('touchstart', handleTouchStart, {passive: true});
        element.removeEventListener('touchend', handleTouchEnd, {passive: true});

        element.addEventListener('touchstart', handleTouchStart, {passive: true});
        element.addEventListener('touchend', handleTouchEnd, {passive: true});
    }


    function prevMonth() { currentMonth--; if (currentMonth < 0) { currentMonth = 11; currentYear--; } renderCalendar(); }
    function nextMonth() { currentMonth++; if (currentMonth > 11) { currentMonth = 0; currentYear++; } renderCalendar(); }


    // --- Modal Edit Functions ---
    function openHotelModal(hotelId) {
        console.log("Attempting to open hotel modal for ID:", hotelId);
        const hotel = tourData.hotels.find(h => h.id === hotelId);
        if (!hotel) {
            console.error("Hotel not found for editing:", hotelId);
            alert("Error: Hotel data not found for editing.");
            return;
        }
        currentEditId = hotelId;
        // Populate form - IMPORTANT: Check if the modal elements exist BEFORE setting values
        const modal = document.getElementById('hotelModal');
        if (!modal) {
             console.error("Hotel modal HTML structure not found!");
             alert("Error: Cannot open edit form.");
             return;
        }

        // Use nullish coalescing (??) to provide default empty values for inputs
        document.getElementById('editHotelName').value = hotel.name ?? '';
        document.getElementById('editHotelAddress').value = hotel.address ?? '';
        document.getElementById('editCheckinDate').value = hotel.checkin ?? '';
        document.getElementById('editCheckoutDate').value = hotel.checkout ?? '';
        document.getElementById('editHotelCostUSD').value = hotel.costUSD ?? 0;
        document.getElementById('editHotelCostCAD').value = hotel.costCAD ?? 0; // Populate manual CAD if present
        document.getElementById('editHotelNotes').value = hotel.notes ?? '';

        modal.style.display = 'block';
         console.log("Hotel modal opened for ID:", hotelId);
    }
    function openVenueModal(venueId) {
         console.log("Attempting to open venue modal for ID:", venueId);
         const venue = tourData.venues.find(v => v.id === venueId);
         if (!venue) {
             console.error("Venue not found for editing:", venueId);
             alert("Error: Venue data not found for editing.");
             return;
         }
         currentEditId = venueId;
         // Populate form - IMPORTANT: Check if the modal elements exist BEFORE setting values
         const modal = document.getElementById('venueModal');
         if (!modal) {
              console.error("Venue modal HTML structure not found!");
              alert("Error: Cannot open edit form.");
              return;
         }

         // Use nullish coalescing (??)
         document.getElementById('editVenueName').value = venue.name ?? '';
         document.getElementById('editVenueAddress').value = venue.address ?? '';
         document.getElementById('editShowDate').value = venue.date ?? '';
         document.getElementById('editShowTime').value = venue.time ?? '';
         document.getElementById('editStartInventory').value = venue.startInventory ?? 0;
         document.getElementById('editEndInventory').value = venue.endInventory ?? 0;
         document.getElementById('editTotalSales').value = venue.totalSales ?? 0;
         document.getElementById('editVenueNotes').value = venue.notes ?? '';

         modal.style.display = 'block';
         console.log("Venue modal opened for ID:", venueId);
     }

    function closeModal(modalId) {
         const modal = document.getElementById(modalId);
         if (modal) {
              modal.style.display = 'none';
              currentEditId = null; // Clear edit ID on close
              console.log("Modal closed:", modalId);
         }
    }

    function saveHotelEdit() {
        console.log("Attempting to save hotel edit for ID:", currentEditId);
        const hotelIndex = tourData.hotels.findIndex(h => h.id === currentEditId);
        if (hotelIndex === -1) {
             console.error("Hotel not found for saving:", currentEditId);
             alert("Error: Hotel data not found for saving.");
             return;
        }

        // Get input elements from modal form
        const nameInput = document.getElementById('editHotelName');
        const addressInput = document.getElementById('editHotelAddress');
        const checkinInput = document.getElementById('editCheckinDate');
        const checkoutInput = document.getElementById('editCheckoutDate');
        const usdInput = document.getElementById('editHotelCostUSD');
        const cadInput = document.getElementById('editHotelCostCAD');
        const notesInput = document.getElementById('editHotelNotes');

         if (!nameInput || !addressInput || !checkinInput || !checkoutInput || !usdInput || !cadInput || !notesInput) {
              console.error("Hotel modal form elements not found!");
              alert("Error: Cannot save, form elements missing.");
              return;
         }

        const editedHotel = tourData.hotels[hotelIndex]; // Reference to the actual object in the array
        editedHotel.name = nameInput.value.trim();
        editedHotel.address = addressInput.value.trim();
        editedHotel.checkin = checkinInput.value;
        editedHotel.checkout = checkoutInput.value;
        editedHotel.costUSD = parseFloat(usdInput.value) || 0;
        editedHotel.costCAD = parseFloat(cadInput.value) || 0;
        editedHotel.notes = notesInput.value.trim();

        // Basic validation again on save
         if (!editedHotel.name || !editedHotel.address || !editedHotel.checkin) {
             alert('Please fill in hotel name, full address, and check-in date.');
             return;
         }
         if (editedHotel.checkout && new Date(editedHotel.checkin) > new Date(editedHotel.checkout)) {
              alert('Check-out date cannot be before check-in date.');
              return;
         }

        saveData(); // Save changes
        updateAllDisplays(); // Refresh UI
        closeModal('hotelModal');
         console.log("Hotel edit saved for ID:", currentEditId);
    }

    function saveVenueEdit() {
         console.log("Attempting to save venue edit for ID:", currentEditId);
         const venueIndex = tourData.venues.findIndex(v => v.id === currentEditId);
         if (venueIndex === -1) {
             console.error("Venue not found for saving:", currentEditId);
             alert("Error: Venue data not found for saving.");
             return;
         }

         // Get input elements from modal form
         const nameInput = document.getElementById('editVenueName');
         const addressInput = document.getElementById('editVenueAddress');
         const dateInput = document.getElementById('editShowDate');
         const timeInput = document.getElementById('editShowTime');
         const startInvInput = document.getElementById('editStartInventory');
         const endInvInput = document.getElementById('editEndInventory');
         const salesInput = document.getElementById('editTotalSales');
         const notesInput = document.getElementById('editVenueNotes');

          if (!nameInput || !addressInput || !dateInput || !timeInput || !startInvInput || !endInvInput || !salesInput || !notesInput) {
               console.error("Venue modal form elements not found!");
               alert("Error: Cannot save, form elements missing.");
               return;
          }

         const editedVenue = tourData.venues[venueIndex]; // Reference to the actual object in the array
         editedVenue.name = nameInput.value.trim();
         editedVenue.address = addressInput.value.trim();
         editedVenue.date = dateInput.value;
         editedVenue.time = timeInput.value;
         editedVenue.startInventory = parseInt(startInvInput.value) || 0;
         editedVenue.endInventory = parseInt(endInvInput.value) || 0;
         editedVenue.totalSales = parseFloat(salesInput.value) || 0;
         editedVenue.notes = notesInput.value.trim();

         // Basic validation on save
         if (!editedVenue.name || !editedVenue.address || !editedVenue.date) {
              alert('Please fill in venue name, full address, and show date.');
              return;
         }


         saveData(); // Save changes
         updateAllDisplays(); // Refresh UI
         closeModal('venueModal');
         console.log("Venue edit saved for ID:", currentEditId);
    }

    // Delete function specific for modals (uses currentEditId)
     function deleteHotel() {
         if (confirm('Are you sure you want to delete this hotel? This cannot be undone!')) {
              console.log("Attempting to delete hotel ID:", currentEditId);
             tourData.hotels = tourData.hotels.filter(h => h.id !== currentEditId);
             // Also remove this hotel from route planner if it's used
              tourData.routePlannerState = tourData.routePlannerState.map(stop =>
                   stop.selectValue === `Hotel:${currentEditId}` ? { selectValue: '', dateValue: stop.dateValue } : stop
              ).filter(stop => stop.selectValue !== ''); // Remove empty stops resulting from deletion if desired
               // Ensure at least one empty stop remains if the list becomes empty
              if (tourData.routePlannerState.length === 0) {
                   tourData.routePlannerState = [{ selectValue: '', dateValue: '' }];
                   routeStopCounter = 1; // Reset counter
               } else {
                    routeStopCounter = tourData.routePlannerState.length; // Update counter
               }

             saveData(); // Save changes
             updateAllDisplays(); // Refresh UI
             closeModal('hotelModal');
             console.log("Hotel deleted ID:", currentEditId);
         }
     }

    // Delete function specific for modals (uses currentEditId)
     function deleteVenue() {
          if (confirm('Are you sure you want to delete this venue? This cannot be undone!')) {
              console.log("Attempting to delete venue ID:", currentEditId);
              tourData.venues = tourData.venues.filter(v => v.id !== currentEditId);
              // Also remove this venue from route planner if it's used
               tourData.routePlannerState = tourData.routePlannerState.map(stop =>
                   stop.selectValue === `Venue:${currentEditId}` ? { selectValue: '', dateValue: stop.dateValue } : stop
               ).filter(stop => stop.selectValue !== ''); // Remove empty stops resulting from deletion if desired
               // Ensure at least one empty stop remains if the list becomes empty
               if (tourData.routePlannerState.length === 0) {
                    tourData.routePlannerState = [{ selectValue: '', dateValue: '' }];
                    routeStopCounter = 1; // Reset counter
                } else {
                     routeStopCounter = tourData.routePlannerState.length; // Update counter
                }

              saveData(); // Save changes
              updateAllDisplays(); // Refresh UI
              closeModal('venueModal');
              console.log("Venue deleted ID:", currentEditId);
          }
      }


    // --- Display Functions ---
    // updateHotelsDisplay, updateExpensesDisplay, updateVenuesDisplay
    // Refactored to use programmatic element creation and addEventListener

    function updateHotelsDisplay() {
        const hotelsList = document.getElementById('hotelsList');
        hotelsList.innerHTML = ''; // Clear current list

        const sortedHotels = [...tourData.hotels].sort((a, b) => new Date(a.checkin) - new Date(b.checkin));
        let totalCAD = 0;
        let totalNights = 0;

        sortedHotels.forEach(hotel => {
            const displayCAD = hotel.costCAD > 0 ? hotel.costCAD : (hotel.costUSD * 1.35);
            totalCAD += displayCAD;

             if (hotel.checkin && hotel.checkout) {
                 const checkin = new Date(hotel.checkin + 'T00:00:00'); // Use T00:00:00 for consistent day start
                 const checkout = new Date(hotel.checkout + 'T00:00:00');
                 if (checkout >= checkin) {
                      const diffTime = checkout.getTime() - checkin.getTime();
                      totalNights += Math.ceil(diffTime / (1000 * 60 * 60 * 24)); // Difference in days = number of nights
                 }
             }

            const cadClass = hotel.costCAD > 0 ? 'manual-cad' : 'approx-cad';

            const hotelCard = document.createElement('div');
            hotelCard.className = 'hotel-card';
            // Add click listener to open modal
            hotelCard.addEventListener('click', () => openHotelModal(hotel.id));

            hotelCard.innerHTML = `
                <div class="card-header">
                    <strong class="card-title">${hotel.name ?? 'N/A'}</strong>
                    <small class="card-date">${formatDate(hotel.checkin)} - ${formatDate(hotel.checkout)}</small>
                </div>
                <div style="color: #ccc; font-size: 12px; margin-bottom: 8px;">📍 ${hotel.address ? hotel.address.substring(0, 50) + (hotel.address.length > 50 ? '...' : '') : 'N/A'}</div>
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span>USD: ${(hotel.costUSD ?? 0).toFixed(0)} | <span class="${cadClass}">CAD: ${displayCAD.toFixed(0)}${hotel.costCAD === 0 ? '*' : ''}</span></span>
                    <button class="btn btn-small btn-danger delete-btn">×</button> <!-- Delete button here -->
                </div>
                ${hotel.notes ? `<div style="margin-top: 8px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px; font-size: 11px;">📝 ${hotel.notes}</div>` : ''}
            `;
            hotelsList.appendChild(hotelCard);

             // Find the delete button within the newly created card and add its listener
            const deleteButton = hotelCard.querySelector('.delete-btn');
             if (deleteButton) {
                  deleteButton.addEventListener('click', (event) => {
                      event.stopPropagation(); // Prevent the card click event from firing
                      deleteItem('hotel', hotel.id); // Call delete function with type and ID
                  });
             }
        });


        document.getElementById('hotelCountStat').textContent = tourData.hotels.length;
        document.getElementById('hotelDaysStat').textContent = Math.round(totalNights);
        document.getElementById('hotelCostStat').textContent = '$' + totalCAD.toFixed(0);
    }


    function updateExpensesDisplay() {
        const expensesList = document.getElementById('expensesList');
         expensesList.innerHTML = ''; // Clear current list

        let totalCAD = 0;
        const sortedExpenses = [...tourData.expenses].sort((a, b) => new Date(a.date) - new Date(b.date));

        sortedExpenses.forEach(expense => {
             const displayCAD = expense.amountCAD > 0 ? expense.amountCAD : (expense.amountUSD * 1.35);
            totalCAD += displayCAD;

             const expenseRow = document.createElement('div');
             expenseRow.className = 'expense-row';
             // expenseRow.addEventListener('click', () => openExpenseModal(expense.id)); // Uncomment if you add an expense edit modal

             // Add content divs
             const dateDiv = document.createElement('div'); dateDiv.className = 'exp-date'; dateDiv.textContent = formatDate(expense.date); expenseRow.appendChild(dateDiv);

             const typeDiv = document.createElement('div'); typeDiv.className = 'exp-type'; typeDiv.textContent = expense.type ?? 'N/A'; expenseRow.appendChild(typeDiv);

             const locDiv = document.createElement('div'); locDiv.className = 'exp-loc'; locDiv.textContent = (expense.location || 'N/A').substring(0, 15) + ((expense.location || '').length > 15 ? '...' : ''); expenseRow.appendChild(locDiv);

             const usdDiv = document.createElement('div'); usdDiv.className = 'exp-usd'; usdDiv.textContent = (expense.amountUSD ?? 0).toFixed(0); expenseRow.appendChild(usdDiv);

             const cadDiv = document.createElement('div'); cadDiv.className = `exp-cad ${expense.amountCAD > 0 ? 'manual-cad' : 'approx-cad'}`; cadDiv.textContent = `${displayCAD.toFixed(0)}${expense.amountCAD === 0 ? '*' : ''}`; expenseRow.appendChild(cadDiv);

             const actionsDiv = document.createElement('div'); actionsDiv.className = 'exp-actions';
             const deleteButton = document.createElement('button');
             deleteButton.className = 'btn btn-small btn-danger delete-btn';
             deleteButton.textContent = '×';
             // Add click listener for delete
             deleteButton.addEventListener('click', (event) => {
                  event.stopPropagation(); // Prevent potential row click logic if added later
                  deleteItem('expense', expense.id); // Call delete function with type and ID
             });
             actionsDiv.appendChild(deleteButton);
             expenseRow.appendChild(actionsDiv);


             expensesList.appendChild(expenseRow);
        });

        document.getElementById('expenseCountStat').textContent = tourData.expenses.length;
        document.getElementById('expenseCostStat').textContent = '$' + totalCAD.toFixed(0);
    }


    function updateVenuesDisplay() {
        const venuesList = document.getElementById('venuesList');
        venuesList.innerHTML = ''; // Clear current list

        const sortedVenues = [...tourData.venues].sort((a, b) => new Date(a.date) - new Date(b.date));
        let totalSales = 0;

        sortedVenues.forEach(venue => {
            totalSales += venue.totalSales;
            const soldItems = (venue.startInventory != null && venue.endInventory != null) ? (parseInt(venue.startInventory) || 0) - (parseInt(venue.endInventory) || 0) : 'N/A';

            const venueCard = document.createElement('div');
            venueCard.className = 'venue-card';
             // Add click listener to open modal
            venueCard.addEventListener('click', () => openVenueModal(venue.id));


             venueCard.innerHTML = `
                 <div class="card-header">
                     <strong class="card-title">${venue.name ?? 'N/A'}</strong>
                     <small class="card-date">${formatDate(venue.date)} @ ${formatTime(venue.time)}</small>
                 </div>
                 <div style="color: #ccc; font-size: 12px; margin-bottom: 8px;">📍 ${venue.address ? venue.address.substring(0, 50) + (venue.address.length > 50 ? '...' : '') : 'N/A'}</div>
                 <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                     <span style="font-size: 12px;">Inventory: Start ${venue.startInventory ?? 'N/A'} | End ${venue.endInventory ?? 'N/A'} | Sold ${soldItems}</span>
                 </div>
                 <div style="display: flex; justify-content: space-between; align-items: center;">
                     <span style="color: #4CAF50; font-weight: bold;">Sales: ${(venue.totalSales ?? 0).toLocaleString()} USD</span>
                     <button class="btn btn-small btn-danger delete-btn">×</button> <!-- Delete button here -->
                 </div>
                 ${venue.notes ? `<div style="margin-top: 8px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px; font-size: 11px;">📝 ${venue.notes}</div>` : ''}
             `;
            venuesList.appendChild(venueCard);

             // Find the delete button within the newly created card and add its listener
             const deleteButton = venueCard.querySelector('.delete-btn');
              if (deleteButton) {
                  deleteButton.addEventListener('click', (event) => {
                      event.stopPropagation(); // Prevent the card click event from firing
                      deleteItem('venue', venue.id); // Call delete function with type and ID
                  });
              }
        });

        document.getElementById('venueCountStat').textContent = tourData.venues.length;
        document.getElementById('venueSalesStat').textContent = '$' + totalSales.toLocaleString();
    }


    window.onclick = function(event) {
         // Check if the click is directly on the modal backdrop, not inside the modal content
         if (event.target === document.getElementById('hotelModal')) closeModal('hotelModal');
         if (event.target === document.getElementById('venueModal')) closeModal('venueModal');
         if (event.target === document.getElementById('calendarModal')) closeModal('calendarModal');
    }

    function exportTourData() {
        const includeHotels = document.getElementById('exportHotels').checked;
        const includeVenues = document.getElementById('exportVenues').checked;
        const includeExpenses = document.getElementById('exportExpenses').checked;
        const includeRoute = document.getElementById('exportRoute').checked;
        let csvData = [['Category', 'Date', 'Name/Info', 'Location/Address', 'Amount', 'Currency', 'Notes']];

        if(includeHotels) tourData.hotels.forEach(h => {
            const displayCAD = h.costCAD > 0 ? h.costCAD : (h.costUSD * 1.35);
            csvData.push(['Hotel', h.checkin || 'N/A', h.name || 'N/A', h.address || 'N/A', displayCAD.toFixed(2), 'CAD (Estimate if not Manual)', `Check-out: ${h.checkout || 'N/A'} | ${h.notes || ''}`]);
        });
        if(includeVenues) tourData.venues.forEach(v => {
             const soldItems = (v.startInventory != null && v.endInventory != null) ? (parseInt(v.startInventory) || 0) - (parseInt(v.endInventory) || 0) : 'N/A';
             csvData.push(['Venue', v.date || 'N/A', v.name || 'N/A', v.address || 'N/A', v.totalSales ?? 0, 'USD', `Time: ${v.time || 'N/A'} | Sold: ${soldItems} | ${v.notes || ''}`]);
        });
        if(includeExpenses) tourData.expenses.forEach(e => {
            const displayCAD = e.amountCAD > 0 ? e.amountCAD : (e.amountUSD * 1.35);
             csvData.push(['Expense', e.date || 'N/A', e.type || 'N/A', e.location || 'N/A', displayCAD.toFixed(2), 'CAD (Estimate if not Manual)', e.notes || '']);
        });

        if (includeRoute) {
            csvData.push(['---','---','---','---','---','---','---']);
            csvData.push(['ROUTE ITINERARY', 'Sequence Start Date', 'From', 'To', 'Distance', 'Time', 'Est. Gas (CAD)']);
            // Sort cache keys by date for ordered export
            Object.keys(tourData.routeCache).sort().forEach(key => {
                 const cacheEntry = tourData.routeCache[key];
                 // Ensure valid cache entry
                 if (!cacheEntry || !cacheEntry.data || !Array.isArray(cacheEntry.data.legs) || !Array.isArray(cacheEntry.data.stops) || cacheEntry.data.legs.length === 0) {
                     console.warn(`Skipping invalid cache entry for export: ${key}`);
                     return;
                 }
                const sequenceData = cacheEntry.data;
                const date = key.split('_')[0]; // Sequence start date

                sequenceData.legs.forEach((leg, index) => {
                    const fromStop = sequenceData.stops[index];
                    const toStop = sequenceData.stops[index+1];
                    const gasCost = calculateGasCost(leg.distance.value); // Calculate gas dynamically

                    csvData.push(['Segment', date, fromStop.name || 'N/A', toStop.name || 'N/A', leg.distance.text, (leg.duration_in_traffic || leg.duration).text, gasCost.toFixed(2)]);
                });
            });
        }

        const csv = csvData.map(row => row.map(cell => {
            // Handle null/undefined and escape quotes
            const stringCell = (cell ?? '').toString();
            return `"${stringCell.replace(/"/g, '""')}"`;
        }).join(',')).join('\n');

        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.setAttribute('download', `tour-data-${new Date().toISOString().split('T')[0]}.csv`);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    // Ensure initial load happens
    // loadData() is called by window.onload
</script>
</body>
</html>