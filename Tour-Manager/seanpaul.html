<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport"/>
<meta content="yes" name="apple-mobile-web-app-capable"/>
<meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/>
<link href="icon.png" rel="apple-touch-icon"/>
<title>Tour Management - Sean Paul × Wiz Khalifa × DaBaby</title>
<style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Arial', sans-serif; background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460); color: #fff; min-height: 100vh; -webkit-user-select: none; -webkit-touch-callout: none; -webkit-tap-highlight-color: transparent; }
        .header { background: linear-gradient(90deg, #ff6b35, #f7931e, #ffd700); padding: 15px; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.3); position: sticky; top: 0; z-index: 100; }
        .header h1 { font-size: 1.6em; font-weight: bold; color: #000; text-shadow: 2px 2px 4px rgba(255,255,255,0.3); margin-bottom: 5px; }
        .artist-logos { display: flex; justify-content: center; gap: 10px; margin-top: 8px; }
        .logo-placeholder { width: 80px; height: 35px; background: linear-gradient(45deg, #000, #333); border-radius: 6px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 9px; color: #ffd700; border: 1px solid #ffd700; }
        .container { max-width: 430px; margin: 0 auto; height: calc(100vh - 120px); display: flex; flex-direction: column; }

        /* --- FIX: Tab navigation to fit, remove scrolling --- */
        .tab-navigation {
             display: flex;
             background: rgba(255,255,255,0.1);
             border-radius: 15px 15px 0 0;
             margin: 10px 10px 0 10px;
             overflow: hidden; /* Hide overflow if content spills */
        }
        .tab-btn {
            flex: 1; /* Allow shrinking and growing */
            min-width: 0; /* Allow content to shrink */
            padding: 8px;
            background: transparent;
            border: none;
            color: #ccc;
            font-weight: bold;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            line-height: 1.2;
            white-space: nowrap; /* Prevent text wrapping */
            overflow: hidden; /* Hide overflowing text */
            text-overflow: ellipsis; /* Add ellipsis */
        }
        /* --- End FIX: Tab navigation --- */

        .tab-btn span { font-size: 1.5em; }
        .tab-btn.active { background: rgba(255,215,0,0.2); color: #ffd700; border-bottom: 3px solid #ffd700; }
        .tab-content { flex: 1; background: rgba(255,255,255,0.1); backdrop-filter: blur(10px); margin: 0 10px 10px 10px; border-radius: 0 0 15px 15px; padding: 15px; overflow-y: auto; display: none; }
        .tab-content.active { display: block; }
        .form-section { background: rgba(255,255,255,0.05); border-radius: 10px; padding: 15px; margin-bottom: 15px; border: 1px solid rgba(255,255,255,0.1); }
        .form-section h3 { color: #ffd700; margin-bottom: 12px; font-size: 1.1em; border-bottom: 1px solid rgba(255,215,0,0.3); padding-bottom: 5px; }
        .form-group { margin-bottom: 10px; }
        .form-group label { display: block; margin-bottom: 4px; color: #fff; font-weight: bold; font-size: 13px; }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 10px; border: none; border-radius: 6px; background: rgba(255,255,255,0.9); color: #000; font-size: 16px; -webkit-appearance: none; }
        .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .form-row-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .form-row-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; }
        .currency-input { position: relative; }
        .currency-prefix { position: absolute; left: 10px; top: 50%; transform: translateY(-50%); color: #666; font-weight: bold; pointer-events: none; z-index: 1; }
        .currency-input input { padding-left: 30px; }
        .btn { background: linear-gradient(45deg, #ff6b35, #f7931e); color: white; border: none; padding: 12px 20px; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 14px; transition: all 0.3s ease; margin: 5px 0; width: 100%; -webkit-tap-highlight-color: transparent; }
        .btn:active { transform: scale(0.98); }
        .btn-small { padding: 6px 12px; font-size: 11px; width: auto; }
        .btn-danger { background: linear-gradient(45deg, #e74c3c, #c0392b); }
        .route-item { background: rgba(255,255,255,0.05); border-radius: 8px; padding: 12px; margin-bottom: 10px; border-left: 4px solid #87CEEB; }
        .route-item.show-day { border-left-color: #ff6b35; }
        .route-item.cached { border-left-color: #4CAF50; }
        .route-item.error { border-left-color: #e74c3c; }
        .stats-grid { display: grid; gap: 8px; margin-bottom: 15px; }
        .stats-grid-2-col { grid-template-columns: 1fr 1fr; }
        .stats-grid-3-col { grid-template-columns: 1fr 1fr 1fr; }
        .stat-card { background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px; text-align: center; border: 1px solid rgba(255,255,255,0.1); }
        .stat-value { font-size: 1.2em; font-weight: bold; color: #ffd700; margin-bottom: 3px; }
        .stat-label { color: #ccc; font-size: 0.8em; }
        .venue-card, .hotel-card { background: rgba(255,255,255,0.05); border-radius: 8px; padding: 12px; margin-bottom: 10px; border-left: 4px solid #ffd700; cursor: pointer; transition: all 0.3s ease; }
        .venue-card:hover, .hotel-card:hover { background: rgba(255,215,0,0.1); transform: translateY(-2px); }
        .card-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 10px; margin-bottom: 8px; }
        .card-title { color: #ffd700; font-weight: bold; flex-grow: 1; word-break: break-word; }
        .card-date { font-weight: bold; color: #fff; white-space: nowrap; flex-shrink: 0; font-size: 11px; }
        .summary-box { background: #16213e; border: 1px solid rgba(255,215,0,0.3); border-radius: 8px; padding: 12px; margin-bottom: 15px; position: sticky; top: -15px; z-index: 10; }
        .day-summary-box { background: rgba(0,0,0,0.2); border: 1px solid rgba(255,215,0,0.2); border-radius: 8px; padding: 12px; margin-top: 20px; margin-bottom: 10px; }
        .day-summary-box h4 { color: #ffd700; text-align: center; margin-bottom: 10px; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); }
        .modal-content { background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460); margin: 10% auto; padding: 20px; border-radius: 15px; width: 90%; max-width: 400px; border: 1px solid rgba(255,215,0,0.3); max-height: 80vh; overflow-y: auto; }
        .modal-header { color: #ffd700; font-size: 1.3em; font-weight: bold; margin-bottom: 15px; border-bottom: 2px solid #ffd700; padding-bottom: 10px; display: flex; justify-content: space-between; align-items: center; }
        .modal-nav { background: none; border: none; color: #ffd700; font-size: 2em; cursor: pointer; padding: 0 10px; }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close:hover { color: #fff; }
        .route-selector { background: rgba(255,255,255,0.05); border-radius: 8px; padding: 15px; margin-bottom: 15px; }
        .route-selector h3 { display: flex; justify-content: space-between; align-items: center; cursor: pointer; }
        #route-builder-content.collapsed { display: none; }
        .toggle-arrow { font-size: 1.2em; transition: transform 0.3s ease; }
        .toggle-arrow.collapsed { transform: rotate(-90deg); }
        .route-controls-bottom { display: flex; gap: 10px; margin-top: 15px; margin-bottom: 15px; }
        .route-step { display: flex; align-items: center; margin-bottom: 10px; }
        .route-step-number { background: #ffd700; color: #000; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-weight: bold; margin-right: 10px; flex-shrink: 0; }
        .route-step select { flex-grow: 1; flex-shrink: 1; min-width: 0; padding: 8px; border-radius: 6px; border: none; background: rgba(255,255,255,0.9); color: #000; font-size: 16px; -webkit-appearance: none; }
        .progress-bar-container { position: relative; }
        .progress-bar { background: rgba(255,255,255,0.1); border-radius: 10px; height: 20px; margin: 10px 0; overflow: hidden; }
        .progress-fill { background: linear-gradient(90deg, #4CAF50, #8BC34A); height: 100%; width: 0%; transition: width 0.3s ease; border-radius: 10px; }
        .progress-text { position: absolute; width: 100%; text-align: center; line-height: 20px; font-size: 11px; font-weight: bold; color: #fff; top: 0; left: 0; }
        input[type="date"], input[type="time"], input[type="number"], select { height: 42px !important; font-size: 16px; padding: 10px; box-sizing: border-box; }
        .checkbox-group { display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; }
        .checkbox-item { display: flex; align-items: center; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 6px; }
        .checkbox-item input { width: 20px; height: 20px; margin-right: 10px; }
        /* Calendar Styles */
        #calendar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        #calendar-header button { background: #ff6b35; border: none; color: white; padding: 8px 12px; border-radius: 6px; cursor: pointer; }
        #month-year { font-size: 1.2em; font-weight: bold; }
        #calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px; }
        .calendar-day { background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); min-height: 80px; border-radius: 8px; padding: 5px; font-size: 0.8em; cursor: pointer; transition: background-color 0.3s; }
        .calendar-day:hover { background: rgba(255,215,0,0.2); }
        .calendar-day.other-month { background: rgba(0,0,0,0.1); color: #666; }
        .day-number { font-weight: bold; }
        .day-events { font-size: 1.5em; line-height: 1; margin-top: 5px; }
        .day-note { font-size: 9px; font-style: italic; color: #ccc; margin-top: 5px; }
</style>
</head>
<body>
<div style="padding: 10px 20px;">
<a href="index.html" style="text-decoration: none; color: #ff6b35; font-size: 1.5em;">← Back</a>
</div>
<div class="header">
<h1>🎤 TOUR MANAGER 🎤</h1>
<div class="artist-logos">
<div class="logo-placeholder">SEAN PAUL</div>
<div class="logo-placeholder">WIZ KHALIFA</div>
<div class="logo-placeholder">DABABY</div>
</div>
</div>
<div class="container">
<div class="tab-navigation">
<button class="tab-btn active" onclick="showTab('calendar')"><span>🗓️</span>CALENDAR</button>
<button class="tab-btn" onclick="showTab('venues')"><span>🎵</span>VENUES</button>
<button class="tab-btn" onclick="showTab('hotels')"><span>🏨</span>HOTELS</button>
<button class="tab-btn" onclick="showTab('routes')"><span>🚗</span>ROUTES</button>
<button class="tab-btn" onclick="showTab('expenses')"><span>💰</span>EXPENSES</button>
<button class="tab-btn" onclick="showTab('settings')"><span>⚙️</span>SETTINGS</button>
</div>
<!-- CALENDAR TAB -->
<div class="tab-content active" id="calendar">
<div id="calendar-header">
<button onclick="prevMonth()">◄ Prev</button>
<div id="month-year"></div>
<button onclick="nextMonth()">Next ►</button>
</div>
<div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px; text-align: center; font-weight: bold; color: #ffd700; font-size: 0.8em; padding-bottom: 5px;">
<div>SUN</div><div>MON</div><div>TUE</div><div>WED</div><div>THU</div><div>FRI</div><div>SAT</div>
</div>
<div id="calendar-grid"></div>
</div>
<!-- VENUES TAB -->
<div class="tab-content" id="venues">
<div class="summary-box">
<div class="stats-grid stats-grid-2-col">
<div class="stat-card"><div class="stat-value" id="venueCountStat">0</div><div class="stat-label">Total Shows</div></div>
<div class="stat-card"><div class="stat-value" id="venueSalesStat">$0</div><div class="stat-label">Total Sales (USD)</div></div>
</div>
</div>
<div id="venuesList"></div>
</div>
<!-- HOTELS TAB -->
<div class="tab-content" id="hotels">
<div class="summary-box">
<div class="stats-grid stats-grid-3-col">
<div class="stat-card"><div class="stat-value" id="hotelCountStat">0</div><div class="stat-label">Total Hotels</div></div>
<div class="stat-card"><div class="stat-value" id="hotelDaysStat">0</div><div class="stat-label">Total Days</div></div>
<div class="stat-card"><div class="stat-value" id="hotelCostStat">$0</div><div class="stat-label">Total Cost</div></div>
</div>
</div>
<div id="hotelsList"></div>
</div>
<!-- ROUTES TAB -->
<div class="tab-content" id="routes">
<div class="summary-box">
<div class="stats-grid stats-grid-3-col">
<div class="stat-card"><div class="stat-value" id="totalDistanceStat">0 km</div><div class="stat-label">Total Distance</div></div>
<div class="stat-card"><div class="stat-value" id="totalTimeStat">0h</div><div class="stat-label">Drive Time</div></div>
<div class="stat-card"><div class="stat-value" id="totalGasStat">$0</div><div class="stat-label">Est. Gas</div></div>
</div>
</div>
<div class="route-selector">
<h3 onclick="toggleRouteBuilder()">🗺️ Build Full Tour Itinerary <span class="toggle-arrow" id="routeBuilderToggleArrow">▼</span></h3>
<div id="route-builder-content">
<div id="routeSteps"><!-- Route steps will be generated by JS --></div>
<div class="route-controls-bottom"><button class="btn btn-small" onclick="addRouteStop()">+ Add Stop</button><button class="btn btn-small" onclick="removeRouteStop()">- Remove Stop</button><button class="btn btn-small" onclick="clearAllStops()">Clear All</button><button class="btn btn-small" onclick="autoFillRoute()">Auto-Fill</button></div>
</div>
<button class="btn" id="generateRouteBtn" onclick="generateCustomRoute()">🛣️ Generate Full Tour Route</button>
<div class="progress-bar-container" id="routeProgress" style="display: none;">
<div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
<div class="progress-text" id="progressText">Preparing...</div>
</div>
<div style="text-align: center; margin-top: 10px;"><span id="routeStopCount" style="color: #ffd700; font-size: 12px;">Stops: 0 / Unlimited</span></div>
</div>
<div id="routeResults"></div>
</div>
<!-- EXPENSES TAB -->
<div class="tab-content" id="expenses">
<div class="summary-box">
<div class="stats-grid stats-grid-2-col">
<div class="stat-card"><div class="stat-value" id="expenseCountStat">0</div><div class="stat-label">Total Expenses</div></div>
<div class="stat-card"><div class="stat-value" id="expenseCostStat">$0</div><div class="stat-label">Total Cost</div></div>
</div>
</div>
<table class="data-table" id="expensesTable"><thead><tr><th>Date</th><th>Type</th><th>Location</th><th>USD</th><th>CAD</th><th>Action</th></tr></thead><tbody id="expensesBody"></tbody></table>
</div>
<!-- SETTINGS (INPUT) TAB -->
<div class="tab-content" id="settings">
<div class="form-section"><h3>🏨 Hotel Confirmations</h3><div class="form-group"><label>Hotel Name</label><input id="hotelName" placeholder="Hotel name" type="text"/></div><div class="form-group"><label>Address</label><input id="hotelAddress" placeholder="Full address" type="text"/></div><div class="form-row"><div class="form-group"><label>Check-in</label><input id="checkinDate" type="date"/></div><div class="form-group"><label>Check-out</label><input id="checkoutDate" type="date"/></div></div><div class="form-row-2"><div class="form-group currency-input"><label>USD Cost</label><span class="currency-prefix">$</span><input id="hotelCostUSD" placeholder="0.00" step="0.01" type="number"/></div><div class="form-group currency-input"><label>Manual CAD</label><span class="currency-prefix">$</span><input id="hotelCostCAD" placeholder="0.00" step="0.01" type="number"/></div></div><div class="form-group"><label>Confirmation Notes</label><textarea id="hotelNotes" placeholder="Confirmation number, special requests, etc." rows="2"></textarea></div><button class="btn" onclick="addHotel()">Add Hotel</button></div>
<div class="form-section"><h3>🎵 Venue Information</h3><div class="form-group"><label>Venue Name</label><input id="venueName" placeholder="Venue name" type="text"/></div><div class="form-group"><label>Address</label><input id="venueAddress" placeholder="Full address" type="text"/></div><div class="form-row"><div class="form-group"><label>Show Date</label><input id="showDate" type="date"/></div><div class="form-group"><label>Show Time</label><input id="showTime" type="time"/></div></div><div class="form-row-3"><div class="form-group"><label>Start Inventory</label><input id="startInventory" placeholder="0" type="number"/></div><div class="form-group"><label>End Inventory</label><input id="endInventory" placeholder="0" type="number"/></div><div class="form-group currency-input"><label>Sales (USD)</label><span class="currency-prefix">$</span><input id="totalSales" placeholder="0.00" step="0.01" type="number"/></div></div><div class="form-group"><label>Venue Notes</label><textarea id="venueNotes" placeholder="Stage setup, sound requirements, etc." rows="2"></textarea></div><button class="btn" onclick="addVenue()">Add Venue</button></div>
<div class="form-section"><h3>💰 Expenses</h3><div class="form-row"><div class="form-group"><label>Type</label><select id="expenseType"><option value="gas">Gas</option><option value="food">Food</option><option value="tolls">Tolls</option><option value="parking">Parking</option><option value="misc">Miscellaneous</option></select></div><div class="form-group"><label>Date</label><input id="expenseDate" type="date"/></div></div><div class="form-group"><label>Location</label><input id="expenseLocation" placeholder="Where was this expense?" type="text"/></div><div class="form-row-2"><div class="form-group currency-input"><label>USD Cost</label><span class="currency-prefix">$</span><input id="expenseAmountUSD" placeholder="0.00" step="0.01" type="number"/></div><div class="form-group currency-input"><label>Manual CAD</label><span class="currency-prefix">$</span><input id="expenseAmountCAD" placeholder="0.00" step="0.01" type="number"/></div></div><div class="form-group"><label>Notes</label><textarea id="expenseNotes" placeholder="Additional notes" rows="2"></textarea></div><button class="btn" onclick="addExpense()">Add Expense</button></div>
<div class="form-section"><h3>📤 Export Data</h3><p style="font-size: 13px; color: #ccc; margin-bottom: 10px;">Select which data to include in your CSV file.</p>
<div class="checkbox-group">
<label class="checkbox-item"><input checked="" id="exportHotels" type="checkbox"/> Hotels</label>
<label class="checkbox-item"><input checked="" id="exportVenues" type="checkbox"/> Venues</label>
<label class="checkbox-item"><input checked="" id="exportExpenses" type="checkbox"/> Expenses</label>
<label class="checkbox-item"><input id="exportRoute" type="checkbox"/> Full Route Itinerary</label>
</div>
<button class="btn" onclick="exportTourData()">Export Selected Data to CSV</button>
</div>
<div style="margin-top:15px">
<label>Fuel Efficiency (km/l):</label>
<input id="kmPerLitre" placeholder="e.g. 8" type="number"/>
<br/><label>Fuel Cost ($/l):</label>
<input id="costPerLitre" placeholder="e.g. 1.75" type="number"/>
<br/><label>Heavy Foot % Increase:</label>
<input id="heavyFootPercent" placeholder="e.g. 10" type="number"/>
<br/>
<button onclick="applySettings()">Apply Settings</button>
<button onclick="uploadLocalToFirebase()">Upload Local → Firebase</button>
</div>
</div>
</div>
<!-- MODALS -->
<div class="modal" id="hotelModal"><div class="modal-content"><div class="modal-header"><span class="close" onclick="closeModal('hotelModal')">×</span><div>Edit Hotel Details</div></div><div id="hotelEditForm"><div class="form-group"><label>Hotel Name</label><input id="editHotelName" type="text"/></div><div class="form-group"><label>Address</label><input id="editHotelAddress" type="text"/></div><div class="form-row"><div class="form-group"><label>Check-in</label><input id="editCheckinDate" type="date"/></div><div class="form-group"><label>Check-out</label><input id="editCheckoutDate" type="date"/></div></div><div class="form-row-2"><div class="currency-input"><label>USD Cost</label><span class="currency-prefix">$</span><input id="editHotelCostUSD" step="0.01" type="number"/></div><div class="currency-input"><label>CAD Cost</label><span class="currency-prefix">$</span><input id="editHotelCostCAD" step="0.01" type="number"/></div></div><div class="form-group"><label>Confirmation Notes</label><textarea id="editHotelNotes" rows="3"></textarea></div><button class="btn" onclick="saveHotelEdit()">Save Changes</button><button class="btn btn-danger" onclick="deleteHotel()">Delete Hotel</button></div></div></div>
<div class="modal" id="venueModal"><div class="modal-content"><div class="modal-header"><span class="close" onclick="closeModal('venueModal')">×</span><div>Edit Venue Details</div></div><div id="venueEditForm"><div class="form-group"><label>Venue Name</label><input id="editVenueName" type="text"/></div><div class="form-group"><label>Address</label><input id="editVenueAddress" type="text"/></div><div class="form-row"><div class="form-group"><label>Show Date</label><input id="editShowDate" type="date"/></div><div class="form-group"><label>Show Time</label><input id="editShowTime" type="time"/></div></div><div class="form-row-3"><div class="form-group"><label>Start Inventory</label><input id="editStartInventory" type="number"/></div><div class="form-group"><label>End Inventory</label><input id="editEndInventory" type="number"/></div><div class="form-group currency-input"><label>Sales (USD)</label><span class="currency-prefix">$</span><input id="editTotalSales" step="0.01" type="number"/></div></div><div class="form-group"><label>Venue Notes</label><textarea id="editVenueNotes" rows="3"></textarea></div><button class="btn" onclick="saveVenueEdit()">Save Changes</button><button class="btn btn-danger" onclick="deleteVenue()">Delete Venue</button></div></div></div>
<div class="modal" id="calendarModal"><div class="modal-content" id="calendarModalContent"></div></div>
<script>
    const GOOGLE_MAPS_API_KEY = 'AIzaSyDk14v_vZFteu3J3ltcs5jXu03AiVqZUZc';
    let tourData = { hotels: [], venues: [], expenses: [], routePlannerState: [], routeCache: {} };
    let currentEditId = null;
    let routeStopCounter = 0;
    let isGeneratingRoute = false;
    let currentMonth = new Date().getMonth();
    let currentYear = new Date().getFullYear();
    let currentModalDate = null;

    function formatDate(dateString) { if (!dateString) return ''; const date = new Date(dateString + 'T00:00:00'); const day = String(date.getDate()).padStart(2, '0'); const month = String(date.getMonth() + 1).padStart(2, '0'); return `${day}-${month}`; }
    function formatTime(timeString) { if (!timeString) return ''; let [hours, minutes] = timeString.split(':'); const ampm = hours >= 12 ? 'PM' : 'AM'; hours = hours % 12 || 12; return `${hours}:${minutes} ${ampm}`; }

    window.onload = function() {
        const savedData = localStorage.getItem('tourData');
        if (savedData) { 
            tourData = JSON.parse(savedData); 
            if (!tourData.routePlannerState) tourData.routePlannerState = []; 
            if (!tourData.routeCache) tourData.routeCache = {}; 
        }
        loadRoutePlannerState();
        showTab('calendar');
        document.getElementById('expenseDate').value = new Date().toISOString().split('T')[0];
    };

    function saveData() { localStorage.setItem('tourData', JSON.stringify(tourData)); }
    
    function showTab(tabName) {
        document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
        document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(tabName).classList.add('active');
        const activeButton = document.querySelector(`.tab-btn[onclick*="'${tabName}'"]`);
        if (activeButton) activeButton.classList.add('active');
        if (tabName === 'calendar') renderCalendar();
        updateAllDisplays();
    }
    
    function addHotel() { const usdCost = parseFloat(document.getElementById('hotelCostUSD').value) || 0; const cadCost = parseFloat(document.getElementById('hotelCostCAD').value) || 0; const hotel = { id: Date.now(), name: document.getElementById('hotelName').value || '', address: document.getElementById('hotelAddress').value || '', checkin: document.getElementById('checkinDate').value || '', checkout: document.getElementById('checkoutDate').value || '', costUSD: usdCost, costCAD: cadCost, approxCAD: usdCost * 1.35, notes: document.getElementById('hotelNotes').value || '', type: 'hotel' }; if (hotel.name && hotel.address && hotel.checkin) { tourData.hotels.push(hotel); saveData(); updateAllDisplays(); clearHotelForm(); alert('Hotel added successfully!'); } else { alert('Please fill in hotel name, full address, and check-in date'); } }
    function addVenue() { const venue = { id: Date.now(), name: document.getElementById('venueName').value || '', address: document.getElementById('venueAddress').value || '', date: document.getElementById('showDate').value || '', time: document.getElementById('showTime').value || '', startInventory: parseInt(document.getElementById('startInventory').value) || 0, endInventory: parseInt(document.getElementById('endInventory').value) || 0, totalSales: parseFloat(document.getElementById('totalSales').value) || 0, notes: document.getElementById('venueNotes').value || '', type: 'venue' }; if (venue.name && venue.address && venue.date) { tourData.venues.push(venue); saveData(); updateAllDisplays(); clearVenueForm(); alert('Venue added successfully!'); } else { alert('Please fill in venue name, full address, and show date'); } }
    function addExpense() { const usdCost = parseFloat(document.getElementById('expenseAmountUSD').value) || 0; const cadCost = parseFloat(document.getElementById('expenseAmountCAD').value) || 0; const expense = { id: Date.now(), type: document.getElementById('expenseType').value, date: document.getElementById('expenseDate').value, location: document.getElementById('expenseLocation').value, amountUSD: usdCost, amountCAD: cadCost, approxCAD: usdCost * 1.35, notes: document.getElementById('expenseNotes').value, category: 'expense' }; if (expense.date && (expense.amountUSD > 0 || expense.amountCAD > 0)) { tourData.expenses.push(expense); saveData(); updateAllDisplays(); clearExpenseForm(); alert('Expense added successfully!'); } else { alert('Please enter date and amount'); } }

    function saveRoutePlannerState() {
        tourData.routePlannerState = Array.from({ length: routeStopCounter }, (_, i) => {
            const select = document.getElementById(`routeSelect${i}`);
            const date = document.getElementById(`routeDate${i}`);
            return { selectValue: select ? select.value : '', dateValue: date ? date.value : '' };
        });
        saveData();
    }
    function loadRoutePlannerState() {
        const routeStepsContainer = document.getElementById('routeSteps');
        routeStepsContainer.innerHTML = '';
        if (!tourData.routePlannerState || tourData.routePlannerState.length === 0) tourData.routePlannerState = [{ selectValue: '', dateValue: '' }];
        routeStopCounter = 0;
        tourData.routePlannerState.forEach(() => addRouteStop(false));
        updateAllDisplays();
    }

    function updateStopCounter() { document.getElementById('routeStopCount').textContent = `Stops: ${routeStopCounter} / Unlimited`; }

    function addRouteStop(shouldSave = true) {
        const routeStepsContainer = document.getElementById('routeSteps');
        const newIndex = routeStopCounter;
        const newStep = document.createElement('div');
        newStep.className = 'route-step';
        newStep.id = `routeStep${newIndex}`;
        newStep.innerHTML = `<div class="route-step-number">${newIndex + 1}</div><select id="routeSelect${newIndex}" onchange="saveRoutePlannerState()"><option value="">-- Select Stop --</option></select><input type="date" id="routeDate${newIndex}" onchange="saveRoutePlannerState()" style="margin-left: 10px; width: 120px; padding: 4px; font-size: 12px; flex-shrink: 0;">`;
        routeStepsContainer.appendChild(newStep);
        routeStopCounter++;
        updateStopCounter();
        if (shouldSave) { saveRoutePlannerState(); updateAllDisplays(); }
    }

    function removeRouteStop() {
        if (routeStopCounter <= 1) return;
        document.getElementById('routeSteps').lastElementChild.remove();
        routeStopCounter--;
        updateStopCounter();
        saveRoutePlannerState();
    }

    function clearAllStops() { 
        tourData.routePlannerState = []; 
        tourData.routeCache = {};
        loadRoutePlannerState(); 
        document.getElementById('routeResults').innerHTML = ''; 
        saveRoutePlannerState(); 
    }

    function autoFillRoute() {
        if (!confirm('This will replace your current route plan with one auto-filled from all hotels and venues, sorted by date. Continue?')) return;
        
        tourData.routePlannerState = [];
        const allStops = [];
        tourData.hotels.forEach(h => { if (h.checkin) allStops.push({ date: h.checkin, stopId: `Hotel:${h.id}`, sortKey: new Date(h.checkin).getTime() }); });
        tourData.venues.forEach(v => { if (v.date) allStops.push({ date: v.date, stopId: `Venue:${v.id}`, sortKey: new Date(v.date).getTime() + 1 }); });
        allStops.sort((a, b) => a.sortKey - b.sortKey);
        tourData.routePlannerState = allStops.map(stop => ({ selectValue: stop.stopId, dateValue: stop.date }));
        if (tourData.routePlannerState.length === 0) tourData.routePlannerState.push({ selectValue: '', dateValue: '' });
        loadRoutePlannerState();
        saveRoutePlannerState();
        alert(`Auto-filled ${allStops.length} stops!`);
    }

    function updateRouteSelects() {
        const allLocations = [...tourData.hotels.map(h => ({ id: h.id, name: h.name, type: 'Hotel' })), ...tourData.venues.map(v => ({ id: v.id, name: v.name, type: 'Venue' }))];
        for (let i = 0; i < routeStopCounter; i++) {
            const select = document.getElementById(`routeSelect${i}`);
            if (select) {
                const savedState = tourData.routePlannerState[i];
                let placeholderText = (i === 0) ? '-- Select Starting Point --' : '-- Select Next Stop --';
                select.innerHTML = `<option value="">${placeholderText}</option>`;
                allLocations.forEach(location => {
                    const option = document.createElement('option');
                    option.value = `${location.type}:${location.id}`;
                    option.textContent = `${location.type}: ${location.name}`;
                    select.appendChild(option);
                });
                if (savedState) { select.value = savedState.selectValue; document.getElementById(`routeDate${i}`).value = savedState.dateValue; }
            }
        }
    }

    function toggleRouteBuilder() {
        const content = document.getElementById('route-builder-content');
        const arrow = document.getElementById('routeBuilderToggleArrow');
        content.classList.toggle('collapsed');
        arrow.classList.toggle('collapsed');
    }

    
async function generateCustomRoute() {
    if (isGeneratingRoute) { alert('Route generation is already in progress...'); return; }
    isGeneratingRoute = true;

    const generateBtn = document.getElementById('generateRouteBtn');
    const progressDiv = document.getElementById('routeProgress');
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    const routeResults = document.getElementById('routeResults');

    generateBtn.disabled = true;
    generateBtn.textContent = '🔄 Generating...';
    progressDiv.style.display = 'block';
    routeResults.innerHTML = '';
    progressText.textContent = 'Preparing route...';
    progressFill.style.width = '0%';

    try {
        const dailySegments = {};
        for (let i = 0; i < tourData.routePlannerState.length - 1; i++) {
            const fromStopInfo = tourData.routePlannerState[i];
            const toStopInfo = tourData.routePlannerState[i + 1];
            if (!fromStopInfo.selectValue || !toStopInfo.selectValue) continue;

            const date = fromStopInfo.dateValue || 'No Date';
            if (!dailySegments[date]) dailySegments[date] = [];
            if (dailySegments[date].length === 0) dailySegments[date].push(getLocationDetails(fromStopInfo.selectValue));
            dailySegments[date].push(getLocationDetails(toStopInfo.selectValue));
        }

        const allDates = Object.keys(dailySegments).sort();
        if (allDates.length === 0) throw new Error('No valid route segments found.');

        let grandTotalDistanceKM = 0, grandTotalTimeSecs = 0, grandTotalGas = 0, processedDays = 0;
        routeResults.innerHTML = '<h3 style="color: #ffd700; margin-bottom: 15px;">🛣️ Generated Route</h3>';

        for (const date of allDates) {
            const stopsForDay = dailySegments[date];
            try {
                const dayRouteData = await processDayRoute(date, stopsForDay);
                grandTotalDistanceKM += dayRouteData.totalDistance || 0;
                grandTotalTimeSecs += dayRouteData.totalTime || 0;
                grandTotalGas += dayRouteData.totalGas || 0;
                renderDayRoute(date, dayRouteData, processedDays + 1);
            } catch (dayError) {
                renderErrorDay(date, processedDays + 1, dayError.message);
            }
            processedDays++;
            const progress = (processedDays / allDates.length) * 100;
            progressFill.style.width = `${progress}%`;
            progressText.textContent = `Day ${processedDays}/${allDates.length} processed...`;
            await new Promise(resolve => setTimeout(resolve, 300));
        }

        const totalHours = Math.floor(grandTotalTimeSecs / 3600);
        const totalMinutes = Math.floor((grandTotalTimeSecs % 3600) / 60);
        document.getElementById('totalDistanceStat').textContent = `${(grandTotalDistanceKM/1000).toFixed(0)} km`;
        document.getElementById('totalTimeStat').textContent = `${totalHours}h ${totalMinutes}m`;
        document.getElementById('totalGasStat').textContent = '$' + grandTotalGas.toFixed(0);
        progressText.textContent = '✅ All days completed!';
    } catch (error) {
        console.error('Route generation error:', error);
        routeResults.innerHTML = `<div class="route-item error"><strong>❌ Error:</strong> ${error.message}</div>`;
        progressText.textContent = '❌ Generation failed';
    } finally {
        isGeneratingRoute = false;
        generateBtn.disabled = false;
        generateBtn.textContent = '🛣️ Generate Full Tour Route';
        setTimeout(() => { progressDiv.style.display = 'none'; }, 3000);
    }
}

async function processDayRoute(date, stopsForDay) {
    if (stopsForDay.length < 2) throw new Error(`Insufficient stops for ${date}`);

    const cacheKey = `${date}_${stopsForDay.map(s => s.address).join('|')}`;
    if (tourData.routeCache[cacheKey] && (Date.now() - tourData.routeCache[cacheKey].timestamp < 7200000)) {
        let cachedData = tourData.routeCache[cacheKey].data;
        cachedData.isCached = true;
        return cachedData;
    }

    let totalDistance = 0, totalTime = 0, totalGas = 0;
    let allLegs = [];

    const MAX_WAYPOINTS = 23;
    for (let i = 0; i < stopsForDay.length - 1; i += MAX_WAYPOINTS) {
        const chunk = stopsForDay.slice(i, i + MAX_WAYPOINTS + 1);
        if (chunk.length < 2) break;

        const origin = chunk[0].address;
        const destination = chunk[chunk.length - 1].address;
        const waypoints = chunk.slice(1, -1).map(s => s.address).join('|');

        const url = `https://maps-proxy-hru8.onrender.com/maps?origin=${encodeURIComponent(origin)}&destination=${encodeURIComponent(destination)}&waypoints=${encodeURIComponent(waypoints)}`;

        const response = await fetch(url);
        if (!response.ok) throw new Error(`API Load failed (status: ${response.status})`);
        const data = await response.json();
        if (data.status !== 'OK') throw new Error(`Google Maps Error: ${data.status}. ${data.error_message || 'Check addresses'}`);

        const legs = data.routes[0].legs;
        allLegs.push(...legs);
        for (let leg of legs) {
            const legKm = leg.distance.value / 1000;
            totalDistance += leg.distance.value;
            totalTime += (leg.duration_in_traffic || leg.duration).value;
            totalGas += (legKm / 100) * 8.5 * 1.75 * 1.20;
        }
    }

    const dayData = {
        legs: allLegs,
        stops: stopsForDay,
        totalDistance,
        totalTime,
        totalGas,
        isCached: false
    };

    tourData.routeCache[cacheKey] = { data: dayData, timestamp: Date.now() };
    saveData();
    return dayData;
}


function renderDayRoute(date, dayData, dayCounter) {
        const routeResults = document.getElementById('routeResults');
        const dayHours = Math.floor(dayData.totalTime / 3600); const dayMinutes = Math.floor((dayData.totalTime % 3600) / 60);
        
        const daySummary = document.createElement('div');
        daySummary.className = 'day-summary-box';
        daySummary.innerHTML = `<h4>Day ${dayCounter} (${date === 'No Date' ? 'No Date' : formatDate(date)}) ✅</h4><div class="stats-grid stats-grid-3-col"><div class="stat-card"><div class="stat-value">${(dayData.totalDistance/1000).toFixed(0)} km</div><div class="stat-label">Day Distance</div></div><div class="stat-card"><div class="stat-value">${dayHours}h ${dayMinutes}m</div><div class="stat-label">Day Drive Time</div></div><div class="stat-card"><div class="stat-value">$${(dayData.totalGas || 0).toFixed(0)}</div><div class="stat-label">Est. Gas</div></div></div>`;
        routeResults.appendChild(daySummary);
        
        dayData.legs.forEach((leg, index) => {
            const legKm = leg.distance.value / 1000;
            const gasCost = (legKm / 100) * 8.5 * 1.75 * 1.20;
            const toStop = dayData.stops[index+1];
            const routeSegment = document.createElement('div');
            routeSegment.className = `route-item ${dayData.isCached ? 'cached' : ''} ${toStop.type === 'Venue' ? 'show-day' : ''}`;
            routeSegment.innerHTML = `<div class="route-header"><strong>${dayData.stops[index].name} → ${toStop.name}</strong><span style="color: ${dayData.isCached ? '#4CAF50' : '#87CEEB'}; font-size: 10px;">✓ ${dayData.isCached ? 'CACHED' : 'REAL-TIME'}</span></div><div class="route-info"><strong>Distance:</strong> ${leg.distance.text} | <strong>Time (traffic):</strong> ${(leg.duration_in_traffic || leg.duration).text}<br><strong>Est. Gas:</strong> $${gasCost.toFixed(0)} CAD</div>`;
            routeResults.appendChild(routeSegment);
        });
    }
    
    function renderErrorDay(date, dayCounter, errorMessage) {
        const routeResults = document.getElementById('routeResults');
        const errorSummary = document.createElement('div');
        errorSummary.className = 'day-summary-box';
        errorSummary.style.borderColor = '#e74c3c';
        errorSummary.innerHTML = `<h4>Day ${dayCounter} (${date === 'No Date' ? 'No Date' : formatDate(date)}) ❌</h4><div class="route-item error"><strong>Error:</strong> ${errorMessage}</div>`;
        routeResults.appendChild(errorSummary);
    }
    
    function renderCalendar() {
        const calendarEl = document.getElementById('calendar-grid');
        const monthYearEl = document.getElementById('month-year');
        if (!calendarEl || !monthYearEl) return;
        calendarEl.innerHTML = '';
        const firstDay = new Date(currentYear, currentMonth, 1).getDay();
        const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
        
        monthYearEl.textContent = `${new Date(currentYear, currentMonth).toLocaleString('default', { month: 'long' })} ${currentYear}`;
        
        for (let i = 0; i < firstDay; i++) { calendarEl.innerHTML += `<div class="calendar-day other-month"></div>`; }

        for (let day = 1; day <= daysInMonth; day++) {
            const dateStr = `${currentYear}-${String(currentMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
            let dayHtml = `<div class="calendar-day" onclick="showDayDetails('${dateStr}')"><div class="day-number">${day}</div>`;
            
            const events = getEventsForDate(dateStr);
            let eventIcons = '';
            if (events.isVenue) { eventIcons += '🎵'; } 
            else if (events.isTravel) { eventIcons += '🚗'; }
            
            dayHtml += `<div class="day-events">${eventIcons}</div>`;
            
            if (dateStr === '2025-07-08') dayHtml += `<div class="day-note">🎂 My Birthday!</div>`;
            if (dateStr === '2025-07-16') dayHtml += `<div class="day-note">Break at Home</div>`;
            if (day % 10 === 0 && !events.isVenue && !events.isTravel) dayHtml += `<div class="day-note">Keep it up!</div>`;

            dayHtml += '</div>';
            calendarEl.innerHTML += dayHtml;
        }
    }
    
    function getEventsForDate(dateStr) {
        let isVenue = tourData.venues.some(v => v.date === dateStr);
        let isTravel = tourData.routePlannerState.some(r => r.dateValue === dateStr);
        return { isVenue, isTravel };
    }

    function showDayDetails(dateStr) {
        const modal = document.getElementById('calendarModal');
        const content = document.getElementById('calendarModalContent');
        
        const venuesOnDay = tourData.venues.filter(v => v.date === dateStr);
        const hotelsOnDay = tourData.hotels.filter(h => dateStr >= h.checkin && dateStr <= h.checkout);
        const stopsForDay = [];
        for (let i = 0; i < tourData.routePlannerState.length - 1; i++) {
             if(tourData.routePlannerState[i].dateValue === dateStr) {
                if (stopsForDay.length === 0) stopsForDay.push(getLocationDetails(tourData.routePlannerState[i].selectValue));
                stopsForDay.push(getLocationDetails(tourData.routePlannerState[i+1].selectValue));
            }
        }

        let html = `<div class="modal-header">
                        <button class="modal-nav prev" onclick="showPrevDay()">◄</button>
                        <div>Details for ${formatDate(dateStr)}</div>
                        <button class="modal-nav next" onclick="showNextDay()">►</button>
                        <span class="close" onclick="closeModal('calendarModal')">&times;</span>
                    </div>`;
        if (venuesOnDay.length > 0) { html += `<h3>🎵 Venues</h3>` + venuesOnDay.map(v => `<div class="route-item">${v.name} @ ${formatTime(v.time)}<br><small>${v.address}</small></div>`).join(''); }
        if (hotelsOnDay.length > 0) { html += `<h3>🏨 Hotels</h3>` + hotelsOnDay.map(h => `<div class="route-item">${h.name}<br><small>Check-in: ${formatDate(h.checkin)} | Check-out: ${formatDate(h.checkout)}</small></div>`).join(''); }
        
        if (stopsForDay.length > 1) {
            const cacheKey = `${dateStr}_${stopsForDay.map(s => s.address).join('|')}`;
            if(tourData.routeCache[cacheKey]) {
                const dayData = tourData.routeCache[cacheKey].data;
                const dayHours = Math.floor(dayData.totalTime / 3600);
                const dayMinutes = Math.floor((dayData.totalTime % 3600) / 60);
                html += `<h3>🚗 Travel Summary</h3>
                         <div class="day-summary-box" style="margin-top:0;">
                            <div class="stats-grid stats-grid-3-col" style="margin-bottom:0;">
                                <div class="stat-card"><div class="stat-value">${(dayData.totalDistance/1000).toFixed(0)} km</div><div class="stat-label">Distance</div></div>
                                <div class="stat-card"><div class="stat-value">${dayHours}h ${dayMinutes}m</div><div class="stat-label">Time</div></div>
                                <div class="stat-card"><div class="stat-value">$${(dayData.totalGas || 0).toFixed(0)}</div><div class="stat-label">Gas</div></div>
                            </div>
                         </div>
                         <h3>Route Segments</h3>`;
                dayData.legs.forEach((leg, index) => {
                    html += `<div class="route-item"><strong>${dayData.stops[index].name} → ${dayData.stops[index+1].name}</strong><br><small>Distance: ${leg.distance.text} | Time: ${(leg.duration_in_traffic || leg.duration).text}</small></div>`;
                });
            } else {
                html += `<h3>🚗 Travel Segments</h3><div class="route-item">Route data not generated. Go to Routes tab and click "Generate".</div>`;
            }
        }
        
        if (venuesOnDay.length === 0 && hotelsOnDay.length === 0 && stopsForDay.length < 2) { html += `<p style="text-align:center; padding: 20px;">No events scheduled for this day.</p>`; }
        content.innerHTML = html;
        modal.style.display = 'block';
        currentModalDate = dateStr;
        addSwipeListeners(modal);
    }

    function showPrevDay() {
        if (!currentModalDate) return;
        let date = new Date(currentModalDate + 'T12:00:00Z');
        date.setDate(date.getDate() - 1);
        showDayDetails(date.toISOString().split('T')[0]);
    }

    function showNextDay() {
        if (!currentModalDate) return;
        let date = new Date(currentModalDate + 'T12:00:00Z');
        date.setDate(date.getDate() + 1);
        showDayDetails(date.toISOString().split('T')[0]);
    }
    
    let touchstartX = 0; let touchendX = 0;
    function handleSwipe() { if (touchendX < touchstartX - 50) showNextDay(); if (touchendX > touchstartX + 50) showPrevDay(); }
    function addSwipeListeners(element) {
        element.addEventListener('touchstart', e => { touchstartX = e.changedTouches[0].screenX; }, {passive: true});
        element.addEventListener('touchend', e => { touchendX = e.changedTouches[0].screenX; handleSwipe(); }, {passive: true});
    }

    function prevMonth() { currentMonth--; if (currentMonth < 0) { currentMonth = 11; currentYear--; } renderCalendar(); }
    function nextMonth() { currentMonth++; if (currentMonth > 11) { currentMonth = 0; currentYear++; } renderCalendar(); }

    function getLocationDetails(locationId) { const [type, id] = locationId.split(':'); const numId = parseInt(id); if (type === 'Hotel') { const hotel = tourData.hotels.find(h => h.id === numId); return hotel ? { ...hotel } : { type: 'Hotel', name: 'N/A', address: 'N/A' }; } else { const venue = tourData.venues.find(v => v.id === numId); return venue ? { ...venue } : { type: 'Venue', name: 'N/A', address: 'N/A' }; } }
    function openHotelModal(hotelId) { const hotel = tourData.hotels.find(h => h.id === hotelId); if (!hotel) return; currentEditId = hotelId; document.getElementById('editHotelName').value = hotel.name; document.getElementById('editHotelAddress').value = hotel.address; document.getElementById('editCheckinDate').value = hotel.checkin; document.getElementById('editCheckoutDate').value = hotel.checkout; document.getElementById('editHotelCostUSD').value = hotel.costUSD; document.getElementById('editHotelCostCAD').value = hotel.costCAD; document.getElementById('editHotelNotes').value = hotel.notes || ''; document.getElementById('hotelModal').style.display = 'block'; }
    function openVenueModal(venueId) { const venue = tourData.venues.find(v => v.id === venueId); if (!venue) return; currentEditId = venueId; document.getElementById('editVenueName').value = venue.name; document.getElementById('editVenueAddress').value = venue.address; document.getElementById('editShowDate').value = venue.date; document.getElementById('editShowTime').value = venue.time; document.getElementById('editStartInventory').value = venue.startInventory; document.getElementById('editEndInventory').value = venue.endInventory; document.getElementById('editTotalSales').value = venue.totalSales; document.getElementById('editVenueNotes').value = venue.notes || ''; document.getElementById('venueModal').style.display = 'block'; }
    function closeModal(modalId) { document.getElementById(modalId).style.display = 'none'; currentEditId = null; }
    function saveHotelEdit() { const hotel = tourData.hotels.find(h => h.id === currentEditId); if (!hotel) return; hotel.name = document.getElementById('editHotelName').value; hotel.address = document.getElementById('editHotelAddress').value; hotel.checkin = document.getElementById('editCheckinDate').value; hotel.checkout = document.getElementById('editCheckoutDate').value; hotel.costUSD = parseFloat(document.getElementById('editHotelCostUSD').value) || 0; hotel.costCAD = parseFloat(document.getElementById('editHotelCostCAD').value) || 0; hotel.approxCAD = hotel.costUSD * 1.35; hotel.notes = document.getElementById('editHotelNotes').value; saveData(); updateAllDisplays(); closeModal('hotelModal'); }
    function saveVenueEdit() { const venue = tourData.venues.find(v => v.id === currentEditId); if (!venue) return; venue.name = document.getElementById('editVenueName').value; venue.address = document.getElementById('editVenueAddress').value; venue.date = document.getElementById('editShowDate').value; venue.time = document.getElementById('editShowTime').value; venue.startInventory = parseInt(document.getElementById('editStartInventory').value) || 0; venue.endInventory = parseInt(document.getElementById('editEndInventory').value) || 0; venue.totalSales = parseFloat(document.getElementById('editTotalSales').value) || 0; venue.notes = document.getElementById('editVenueNotes').value; saveData(); updateAllDisplays(); closeModal('venueModal'); }
    function deleteHotel() { if (confirm('Are you sure?')) { tourData.hotels = tourData.hotels.filter(h => h.id !== currentEditId); saveData(); updateAllDisplays(); closeModal('hotelModal'); } }
    function deleteVenue() { if (confirm('Are you sure?')) { tourData.venues = tourData.venues.filter(v => v.id !== currentEditId); saveData(); updateAllDisplays(); closeModal('venueModal'); } }
    
    function updateAllDisplays() { updateHotelsDisplay(); updateExpensesDisplay(); updateVenuesDisplay(); updateRouteSelects(); }
    
    function updateHotelsDisplay() {
        const hotelsList = document.getElementById('hotelsList'); hotelsList.innerHTML = '';
        const sortedHotels = [...tourData.hotels].sort((a, b) => new Date(a.checkin) - new Date(b.checkin));
        let totalCAD = 0, totalNights = 0;
        sortedHotels.forEach(hotel => {
            totalCAD += hotel.costCAD || (hotel.costUSD * 1.35);
            if (hotel.checkin && hotel.checkout) totalNights += (new Date(hotel.checkout) - new Date(hotel.checkin)) / 86400000;
            const displayCAD = hotel.costCAD > 0 ? hotel.costCAD : (hotel.costUSD * 1.35); const cadClass = hotel.costCAD > 0 ? 'manual-cad' : 'approx-cad';
            const hotelCard = document.createElement('div'); hotelCard.className = 'hotel-card'; hotelCard.onclick = () => openHotelModal(hotel.id);
            hotelCard.innerHTML = `<div class="card-header"><strong class="card-title">${hotel.name}</strong><small class="card-date">${formatDate(hotel.checkin)} - ${formatDate(hotel.checkout)}</small></div><div style="color: #ccc; font-size: 12px; margin-bottom: 8px;">📍 ${hotel.address.substring(0, 50)}...</div><div style="display: flex; justify-content: space-between; align-items: center;"><span>USD: ${hotel.costUSD.toFixed(0)} | <span class="${cadClass}">CAD: ${displayCAD.toFixed(0)}${hotel.costCAD === 0 ? '*' : ''}</span></span><button class="btn btn-small btn-danger" onclick="event.stopPropagation(); deleteItem('hotel', ${hotel.id})">×</button></div>${hotel.notes ? `<div style="margin-top: 8px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px; font-size: 11px;">📝 ${hotel.notes}</div>` : ''}`;
            hotelsList.appendChild(hotelCard);
        });
        document.getElementById('hotelCountStat').textContent = tourData.hotels.length;
        document.getElementById('hotelDaysStat').textContent = Math.round(totalNights);
        document.getElementById('hotelCostStat').textContent = '$' + totalCAD.toFixed(0);
    }

    function updateExpensesDisplay() {
        const tbody = document.getElementById('expensesBody'); tbody.innerHTML = ''; let totalCAD = 0;
        const sortedExpenses = [...tourData.expenses].sort((a, b) => new Date(a.date) - new Date(b.date));
        sortedExpenses.forEach(expense => {
            totalCAD += expense.amountCAD || (expense.amountUSD * 1.35);
            const row = tbody.insertRow(); const displayCAD = expense.amountCAD > 0 ? expense.amountCAD : (expense.amountUSD * 1.35); const cadClass = expense.amountCAD > 0 ? 'manual-cad' : 'approx-cad';
            row.innerHTML = `<td>${formatDate(expense.date)}</td><td>${expense.type}</td><td>${(expense.location || 'N/A').substring(0, 15)}...</td><td>${expense.amountUSD.toFixed(0)}</td><td class="${cadClass}">${displayCAD.toFixed(0)}${expense.amountCAD === 0 ? '*' : ''}</td><td><button class="btn btn-small btn-danger" onclick="event.stopPropagation(); deleteItem('expense', ${expense.id})">×</button></td>`;
        });
        document.getElementById('expenseCountStat').textContent = tourData.expenses.length; document.getElementById('expenseCostStat').textContent = '$' + totalCAD.toFixed(0);
    }
    
    function updateVenuesDisplay() {
        const venuesList = document.getElementById('venuesList'); venuesList.innerHTML = '';
        const sortedVenues = [...tourData.venues].sort((a, b) => new Date(a.date) - new Date(b.date));
        let totalSales = 0;
        sortedVenues.forEach(venue => {
            totalSales += venue.totalSales; const soldItems = venue.startInventory - venue.endInventory;
            const venueCard = document.createElement('div'); venueCard.className = 'venue-card'; venueCard.onclick = () => openVenueModal(venue.id);
            venueCard.innerHTML = `<div class="card-header"><strong class="card-title">${venue.name}</strong><small class="card-date">${formatDate(venue.date)} @ ${formatTime(venue.time)}</small></div><div style="color: #ccc; font-size: 12px; margin-bottom: 8px;">📍 ${venue.address.substring(0, 50)}...</div><div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;"><span style="font-size: 12px;">Inventory: Start ${venue.startInventory} | End ${venue.endInventory} | Sold ${soldItems}</span></div><div style="display: flex; justify-content: space-between; align-items: center;"><span style="color: #4CAF50; font-weight: bold;">Sales: ${venue.totalSales.toLocaleString()} USD</span><button class="btn btn-small btn-danger" onclick="event.stopPropagation(); deleteItem('venue', ${venue.id})">×</button></div>${venue.notes ? `<div style="margin-top: 8px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px; font-size: 11px;">📝 ${venue.notes}</div>` : ''}`;
            venuesList.appendChild(venueCard);
        });
        document.getElementById('venueCountStat').textContent = tourData.venues.length; document.getElementById('venueSalesStat').textContent = '$' + totalSales.toLocaleString();
    }

    function deleteItem(type, id) { if (confirm(`Delete this ${type}?`)) { if (type === 'hotel') tourData.hotels = tourData.hotels.filter(h => h.id !== id); else if (type === 'venue') tourData.venues = tourData.venues.filter(v => v.id !== id); else if (type === 'expense') tourData.expenses = tourData.expenses.filter(e => e.id !== id); saveData(); updateAllDisplays(); } }
    function clearHotelForm() { ['hotelName', 'hotelAddress', 'checkinDate', 'checkoutDate', 'hotelCostUSD', 'hotelCostCAD', 'hotelNotes'].forEach(id => document.getElementById(id).value = ''); }
    function clearVenueForm() { ['venueName', 'venueAddress', 'showDate', 'showTime', 'startInventory', 'endInventory', 'totalSales', 'venueNotes'].forEach(id => document.getElementById(id).value = ''); }
    function clearExpenseForm() { ['expenseAmountUSD', 'expenseAmountCAD', 'expenseLocation', 'expenseNotes'].forEach(id => document.getElementById(id).value = ''); document.getElementById('expenseDate').value = new Date().toISOString().split('T')[0]; }
    
    document.addEventListener('DOMContentLoaded', function() {
        document.getElementById('hotelCostUSD').addEventListener('input', function() { const cadInput = document.getElementById('hotelCostCAD'); if (this.value && cadInput && !cadInput.value) cadInput.placeholder = `≈ ${(parseFloat(this.value) * 1.35).toFixed(2)} CAD`; });
        document.getElementById('expenseAmountUSD').addEventListener('input', function() { const cadInput = document.getElementById('expenseAmountCAD'); if (this.value && cadInput && !cadInput.value) cadInput.placeholder = `≈ ${(parseFloat(this.value) * 1.35).toFixed(2)} CAD`; });
    });
    window.onclick = function(event) { if (event.target === document.getElementById('hotelModal')) closeModal('hotelModal'); if (event.target === document.getElementById('venueModal')) closeModal('venueModal'); if (event.target === document.getElementById('calendarModal')) closeModal('calendarModal'); }
    
    function exportTourData() {
        const includeHotels = document.getElementById('exportHotels').checked;
        const includeVenues = document.getElementById('exportVenues').checked;
        const includeExpenses = document.getElementById('exportExpenses').checked;
        const includeRoute = document.getElementById('exportRoute').checked;
        let csvData = [['Category', 'Date', 'Name/Info', 'Location/Address', 'Amount', 'Currency', 'Notes']];
        if(includeHotels) tourData.hotels.forEach(h => csvData.push(['Hotel', h.checkin, h.name, h.address, (h.costCAD || h.costUSD * 1.35).toFixed(2), 'CAD (Estimate if not Manual)', `Check-out: ${h.checkout} | ${h.notes}`]));
        if(includeVenues) tourData.venues.forEach(v => csvData.push(['Venue', v.date, v.name, v.address, v.totalSales, 'USD', `Time: ${v.time} | Sold: ${v.startInventory-v.endInventory}`]));
        if(includeExpenses) tourData.expenses.forEach(e => csvData.push(['Expense', e.date, e.type, e.location, (e.amountCAD || e.amountUSD * 1.35).toFixed(2), 'CAD (Estimate if not Manual)', e.notes]));
        if (includeRoute) {
            csvData.push(['---','---','---','---','---','---','---']);
            csvData.push(['ROUTE ITINERARY', 'Date', 'From', 'To', 'Distance', 'Time', 'Est. Gas (CAD)']);
            Object.keys(tourData.routeCache).sort().forEach(key => {
                const dayData = tourData.routeCache[key].data;
                const date = key.split('_')[0];
                dayData.legs.forEach((leg, index) => {
                    const fromStop = dayData.stops[index];
                    const toStop = dayData.stops[index+1];
                    const legKm = leg.distance.value / 1000;
                    const gasCost = (legKm / 100) * 12.5 * 1.75 * 1.20;
                    csvData.push(['Segment', date, fromStop.name, toStop.name, leg.distance.text, (leg.duration_in_traffic || leg.duration).text, gasCost.toFixed(2)]);
                });
            });
        }
        
        const csv = csvData.map(row => row.map(cell => `"${(cell ?? '').toString().replace(/"/g, '""')}"`).join(',')).join('\n');
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.setAttribute('download', `tour-data-${new Date().toISOString().split('T')[0]}.csv`);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
</script>
<script>
// --- Start of Firebase & Settings Integration ---

// Firebase SDK
// Added these script tags to the head in the final code
// <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
// <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>


// Firebase Configuration (Using the API key from your original code)
const firebaseConfig = {
  apiKey: "AIzaSyDk14v_vZFteu3J3ltcs5jXu03AiVqZUZc", // Your provided API Key
  authDomain: "tour-manager-b2888.firebaseapp.com", // Your provided Auth Domain
  projectId: "tour-manager-b2888", // Your provided Project ID
  // Add other values from your Firebase project settings if needed
};

// Initialize Firebase
let firebaseApp;
let db; // Firestore database instance
try {
    firebaseApp = firebase.initializeApp(firebaseConfig);
    db = firebaseApp.firestore();
    console.log("Firebase initialized.");
     // Optional: Enable offline persistence (requires indexdb support)
     // firebase.firestore().enablePersistence().catch((err) => { console.warn('Persistence issue:', err); });
} catch (error) {
    console.error("Firebase initialization failed:", error);
    db = null; // Ensure db is null if init fails
}

// Data loading key
const STORAGE_KEY = `tourData_seanpaul`; // Using the specific key


// Modified window.onload to load from Firebase or localStorage
window.onload = async function() {
    let loadedData = null;
    let source = 'default';

    // Attempt to load from Firebase first
    if (db) {
        try {
            const doc = await db.collection("tourData").doc(STORAGE_KEY).get();
            if (doc.exists) {
                loadedData = doc.data();
                source = 'firebase';
                console.log("Data loaded from Firebase.");
            } else {
                console.log("No data found in Firebase for key:", STORAGE_KEY);
            }
        } catch (e) {
            console.error("Failed to load data from Firebase, attempting localStorage:", e);
        }
    }

    // Fallback to localStorage if Firebase load failed or doc didn't exist
    if (!loadedData) {
        const savedDataString = localStorage.getItem(STORAGE_KEY);
        if (savedDataString) {
            try {
                loadedData = JSON.parse(savedDataString);
                source = 'localStorage';
                console.log("Data loaded from localStorage:", STORAGE_KEY);
            } catch (e) {
                 console.error("Failed to parse data from localStorage:", STORAGE_KEY, e);
                 loadedData = null; // Ensure loadedData is null if parsing fails
            }
        } else {
            console.log("No data found in localStorage for key:", STORAGE_KEY);
        }
    }

    // Use loaded data or default
    if (loadedData) {
         // Merge loaded data with default structure to ensure all properties exist
         // Explicitly handle settings merge
        tourData = {
            hotels: [],
            venues: [],
            expenses: [],
            routePlannerState: [],
            routeCache: {},
            settings: { kmPerLitre: 8.5, costPerLitre: 1.75, heavyFootPercent: 10 }, // Default structure
            ...loadedData, // Override with loaded data
            settings: loadedData.settings || { kmPerLitre: 8.5, costPerLitre: 1.75, heavyFootPercent: 10 } // Explicitly handle settings, defaulting if loaded is null/undefined
        };
    } else {
        // Use default tourData initialized globally
        console.log("Using default tourData.");
    }


    // Ensure core arrays and objects exist and settings are numeric after loading/merging
    if (!Array.isArray(tourData.hotels)) tourData.hotels = [];
    if (!Array.isArray(tourData.venues)) tourData.venues = [];
    if (!Array.isArray(tourData.expenses)) tourData.expenses = [];
    if (!Array.isArray(tourData.routePlannerState)) tourData.routePlannerState = [];
    if (tourData.routeCache === null || typeof tourData.routeCache !== 'object') tourData.routeCache = {};

    if (tourData.settings) {
        tourData.settings.kmPerLitre = parseFloat(tourData.settings.kmPerLitre) || 0;
        tourData.settings.costPerLitre = parseFloat(tourData.settings.costPerLitre) || 0;
        tourData.settings.heavyFootPercent = parseFloat(tourData.settings.heavyFootPercent) || 0;
    } else {
         tourData.settings = { kmPerLitre: 8.5, costPerLitre: 1.75, heavyFootPercent: 10 }; // Ensure settings object exists with defaults
    }


    // If data was loaded from localStorage, sync it to Firebase (if connected)
    if (source === 'localStorage' && db) {
        console.log("Loaded from local, syncing to Firebase...");
         db.collection("tourData").doc(STORAGE_KEY).set(tourData)
           .then(() => console.log("Local data synced to Firebase."))
           .catch(e => console.error("Failed to sync local data to Firebase:", e));
    }


    // Initial UI setup based on loaded data
    loadRoutePlannerState(); // This rebuilds route planner UI and calls updateAllDisplays
    populateSettingsForm(); // Load settings into the form inputs
    // updateAllDisplays is called by loadRoutePlannerState -> updateAllDisplays -> showTab('calendar')

    // Set expense date default
    const expenseDateInput = document.getElementById('expenseDate');
    if (expenseDateInput) {
         expenseDateInput.value = new Date().toISOString().split('T')[0];
    }

     // Add event listeners for forms to auto-save on change
     document.querySelectorAll(".form-section input, .form-section select, .form-section textarea").forEach(el => {
          el.addEventListener("change", saveData); // Now saves to LS and Firebase
     });

     // Add listeners for USD inputs to show approx CAD placeholders
     const hotelCostUSD = document.getElementById('hotelCostUSD');
     const hotelCostCAD = document.getElementById('hotelCostCAD');
     if (hotelCostUSD && hotelCostCAD) {
          hotelCostUSD.addEventListener('input', function() { hotelCostCAD.placeholder = this.value ? `≈ ${(parseFloat(this.value) * 1.35).toFixed(2)} CAD` : '0.00'; });
     }
     const expenseAmountUSD = document.getElementById('expenseAmountUSD');
     const expenseAmountCAD = document.getElementById('expenseAmountCAD');
      if (expenseAmountUSD && expenseAmountCAD) {
          expenseAmountUSD.addEventListener('input', function() { expenseAmountCAD.placeholder = this.value ? `≈ ${(parseFloat(this.value) * 1.35).toFixed(2)} CAD` : '0.00'; });
      }

    // showTab('calendar'); // This is called by updateAllDisplays -> renderCalendar
};


// Modified saveData to also save to Firebase
function saveData() {
    try {
        // Ensure settings are numeric before saving
        if (tourData.settings) {
            tourData.settings.kmPerLitre = parseFloat(tourData.settings.kmPerLitre) || 0;
            tourData.settings.costPerLitre = parseFloat(tourData.settings.costPerLitre) || 0;
            tourData.settings.heavyFootPercent = parseFloat(tourData.settings.heavyFootPercent) || 0;
        } else {
             tourData.settings = { kmPerLitre: 8.5, costPerLitre: 1.75, heavyFootPercent: 10 }; // Ensure settings object exists with defaults
        }
         // Ensure core arrays/objects exist
        if (!Array.isArray(tourData.hotels)) tourData.hotels = [];
        if (!Array.isArray(tourData.venues)) tourData.venues = [];
        if (!Array.isArray(tourData.expenses)) tourData.expenses = [];
        if (!Array.isArray(tourData.routePlannerState)) tourData.routePlannerState = [];
        if (tourData.routeCache === null || typeof tourData.routeCache !== 'object') tourData.routeCache = {};


        localStorage.setItem(STORAGE_KEY, JSON.stringify(tourData));
        console.log("Data saved to localStorage:", STORAGE_KEY);

        if (db) {
            // Use the specific STORAGE_KEY for the Firebase document ID
             db.collection("tourData").doc(STORAGE_KEY).set(tourData)
               .then(() => console.log("Data synced to Firebase:", STORAGE_KEY))
               .catch((error) => console.error("Firebase sync failed:", error));
        }
    } catch (e) {
        console.error("Failed to save data:", e);
    }
}


// --- Gas Calculation Logic ---

function calculateGasCost(distanceInMeters) {
    // Use default settings if tourData.settings is missing or values are invalid
    const settings = tourData.settings || {};
    const kmPerLitre = parseFloat(settings.kmPerLitre);
    const costPerLitre = parseFloat(settings.costPerLitre);
    const heavyFootPercent = parseFloat(settings.heavyFootPercent);

    // Basic validation - if essential settings are missing or invalid, return 0
    if (isNaN(kmPerLitre) || kmPerLitre <= 0 || isNaN(costPerLitre) || costPerLitre <= 0) {
         return 0;
    }

    const distanceInKm = distanceInMeters / 1000;
    const litresNeeded = distanceInKm / kmPerLitre;
    let estimatedCost = litresNeeded * costPerLitre;

    if (!isNaN(heavyFootPercent) && heavyFootPercent > 0) {
        estimatedCost *= (1 + heavyFootPercent / 100);
    }

    return estimatedCost;
}


// Modified applySettings to save settings and trigger route update
window.applySettings = function() {
    // Add checks if elements exist before getting value
    const kmInput = document.getElementById("kmPerLitre");
    const costInput = document.getElementById("costPerLitre");
    const heavyInput = document.getElementById("heavyFootPercent");

    const kmPerLitreInput = kmInput ? kmInput.value : '';
    const costPerLitreInput = costInput ? costInput.value : '';
    const heavyFootPercentInput = heavyInput ? heavyInput.value : '';


    // Ensure settings object exists
    if (!tourData.settings) tourData.settings = {};

    // Store as number, default to 0 if invalid input but save even if 0
    tourData.settings.kmPerLitre = parseFloat(kmPerLitreInput) || 0;
    tourData.settings.costPerLitre = parseFloat(costPerLitreInput) || 0;
    tourData.settings.heavyFootPercent = parseFloat(heavyFootPercentInput) || 0;

    saveData(); // Save the updated settings (includes Firebase sync)
    alert("Settings applied and saved.");

    // Re-render route displays to reflect new gas costs immediately
     // Only do this if the Routes tab is currently active for efficiency
    if (document.getElementById('routes').classList.contains('active')) {
        // The original code's generateCustomRoute re-fetched data from API which is slow.
        // Instead, re-render from CACHE using the new settings.
        renderRouteResults(); // This function needs to be updated to use the dynamic gas calculation
        updateRouteSummaryStats(); // This function needs to be updated to use the dynamic gas calculation
    }
     // Calendar and Expenses display updates (called via updateAllDisplays) will also reflect new settings
};

// Removed window.uploadLocalToFirebase function


// --- General Display Functions ---
function updateAllDisplays() {
    updateHotelsDisplay();
    updateExpensesDisplay();
    updateVenuesDisplay();
    updateRouteSelects(); // Updates the dropdowns in the route planner
     // Note: Route results/summary on the Route tab are only updated
     // when the tab is shown or settings are applied, not every time updateAllDisplays is called.
    renderCalendar();
}

// --- Data Entry Functions (Keeping original structure) ---

function addHotel() {
    const usdCost = parseFloat(document.getElementById('hotelCostUSD').value) || 0;
    const cadCost = parseFloat(document.getElementById('hotelCostCAD').value) || 0;
    const hotel = {
        id: Date.now(),
        name: document.getElementById('hotelName').value || '',
        address: document.getElementById('hotelAddress').value || '',
        checkin: document.getElementById('checkinDate').value || '',
        checkout: document.getElementById('checkoutDate').value || '',
        costUSD: usdCost,
        costCAD: cadCost,
        approxCAD: usdCost * 1.35,
        notes: document.getElementById('hotelNotes').value || '',
        type: 'hotel' // Used by getLocationDetails
    };
    if (hotel.name && hotel.address && hotel.checkin) {
        tourData.hotels.push(hotel);
        saveData(); // Saves to LS and Firebase
        updateAllDisplays();
        clearHotelForm();
        alert('Hotel added successfully!');
    } else {
        alert('Please fill in hotel name, full address, and check-in date');
    }
}

function addVenue() {
    const venue = {
        id: Date.now(),
        name: document.getElementById('venueName').value || '',
        address: document.getElementById('venueAddress').value || '',
        date: document.getElementById('showDate').value || '',
        time: document.getElementById('showTime').value || '',
        startInventory: parseInt(document.getElementById('startInventory').value) || 0,
        endInventory: parseInt(document.getElementById('endInventory').value) || 0,
        totalSales: parseFloat(document.getElementById('totalSales').value) || 0,
        notes: document.getElementById('venueNotes').value || '',
        type: 'venue' // Used by getLocationDetails
    };
    if (venue.name && venue.address && venue.date) {
        tourData.venues.push(venue);
        saveData(); // Saves to LS and Firebase
        updateAllDisplays();
        clearVenueForm();
        alert('Venue added successfully!');
    } else {
        alert('Please fill in venue name, full address, and show date');
    }
}

function addExpense() {
    const usdCost = parseFloat(document.getElementById('expenseAmountUSD').value) || 0;
    const cadCost = parseFloat(document.getElementById('expenseAmountCAD').value) || 0;
    const expense = {
        id: Date.now(),
        type: document.getElementById('expenseType').value,
        date: document.getElementById('expenseDate').value,
        location: document.getElementById('expenseLocation').value,
        amountUSD: usdCost,
        amountCAD: cadCost,
        approxCAD: usdCost * 1.35,
        notes: document.getElementById('expenseNotes').value,
        category: 'expense' // Used internally
    };
    if (expense.date && (expense.amountUSD > 0 || expense.amountCAD > 0)) {
        tourData.expenses.push(expense);
        saveData(); // Saves to LS and Firebase
        updateAllDisplays();
        clearExpenseForm();
        alert('Expense added successfully!');
    } else {
        alert('Please enter date and amount');
    }
}


// --- Route Builder Logic (Keeping original structure) ---

function saveRoutePlannerState() {
    tourData.routePlannerState = Array.from({ length: routeStopCounter }, (_, i) => {
        const select = document.getElementById(`routeSelect${i}`);
        const date = document.getElementById(`routeDate${i}`);
        return { selectValue: select ? select.value : '', dateValue: date ? date.value : '' };
    });
    saveData(); // Saves to LS and Firebase
}

function loadRoutePlannerState() {
    const routeStepsContainer = document.getElementById('routeSteps');
    if (!routeStepsContainer) return; // Safety check
    routeStepsContainer.innerHTML = '';
    // Ensure routePlannerState is an array
    if (!Array.isArray(tourData.routePlannerState)) tourData.routePlannerState = [];
    // Ensure at least one stop
    if (tourData.routePlannerState.length === 0) tourData.routePlannerState = [{ selectValue: '', dateValue: '' }];

    routeStopCounter = 0; // Reset counter
    // Add stops based on the loaded state
    tourData.routePlannerState.forEach(() => addRouteStop(false)); // Add stops without saving immediately

    updateStopCounter(); // Update counter display
    updateAllDisplays(); // Updates selects, displays data (which will use dynamic gas)
}

function updateStopCounter() {
    const countEl = document.getElementById('routeStopCount');
    if (countEl) countEl.textContent = `Stops: ${routeStopCounter} / Unlimited`;
}

function addRouteStop(shouldSave = true) {
    const routeStepsContainer = document.getElementById('routeSteps');
    if (!routeStepsContainer) return; // Safety check

    const newIndex = routeStopCounter;
    const newStep = document.createElement('div');
    newStep.className = 'route-step';
    newStep.id = `routeStep${newIndex}`;
    // InnerHTML with onclick handlers
    newStep.innerHTML = `<div class="route-step-number">${newIndex + 1}</div><select id="routeSelect${newIndex}" onchange="saveRoutePlannerState()"><option value="">-- Select Stop --</option></select><input type="date" id="routeDate${newIndex}" onchange="saveRoutePlannerState()" style="margin-left: 10px; width: 120px; padding: 4px; font-size: 12px; flex-shrink: 0;">`;

    routeStepsContainer.appendChild(newStep);
    routeStopCounter++;
    updateStopCounter();

     // Add an empty entry to routePlannerState for the new stop if needed
     if (!tourData.routePlannerState[newIndex]) {
          tourData.routePlannerState[newIndex] = { selectValue: '', dateValue: '' };
     } else {
          // If adding at the end, ensure it's added to the array
           tourData.routePlannerState.push({ selectValue: '', dateValue: '' });
     }


    updateRouteSelects(); // Populate selects and update state values

    if (shouldSave) {
         saveData(); // Save updated state (includes new empty stop)
         // updateAllDisplays(); // Not strictly needed here as updateRouteSelects calls saveData
     }
}

function removeRouteStop() {
    if (routeStopCounter <= 1) return;
    const lastStep = document.getElementById('routeSteps').lastElementChild;
    if (lastStep) {
        lastStep.remove();
        routeStopCounter--;
        updateStopCounter();
        // Remove the last entry from the state
         if (tourData.routePlannerState.length > routeStopCounter) {
              tourData.routePlannerState.pop();
         }
        saveRoutePlannerState(); // Save state
    }
}

function clearAllStops() {
    if (confirm('Are you sure you want to clear all route stops and cached route data? This cannot be undone!')) {
        tourData.routePlannerState = [];
        tourData.routeCache = {};
        saveData(); // Save cleared state
        loadRoutePlannerState(); // Reset UI (adds 1 empty stop) and updates displays
        const routeResults = document.getElementById('routeResults');
         if (routeResults) routeResults.innerHTML = ''; // Clear displayed results
        updateRouteSummaryStats(); // Reset total stats
    }
}

function autoFillRoute() {
    if (!confirm('This will replace your current route plan with one auto-filled from all hotels and venues, sorted by date. Continue?')) return;

    tourData.routePlannerState = [];
    const allStops = [];
    tourData.hotels.forEach(h => { if (h.checkin) allStops.push({ date: h.checkin, stopId: `Hotel:${h.id}`, sortKey: new Date(h.checkin).getTime() }); });
    tourData.venues.forEach(v => { if (v.date) allStops.push({ date: v.date, stopId: `Venue:${v.id}`, sortKey: new Date(v.date).getTime() + 1 }); });
    allStops.sort((a, b) => a.sortKey - b.sortKey);
    tourData.routePlannerState = allStops.map(stop => ({ selectValue: stop.stopId, dateValue: stop.date }));
    if (tourData.routePlannerState.length === 0) tourData.routePlannerState.push({ selectValue: '', dateValue: '' });

    saveData(); // Save auto-filled state
    loadRoutePlannerState(); // Reload UI and displays
    alert(`Auto-filled ${allStops.length} stops!`);
}

// Modified updateRouteSelects to ensure state is updated based on UI
function updateRouteSelects() {
    const allLocations = [...tourData.hotels.map(h => ({ id: h.id, name: h.name, type: 'Hotel' })), ...tourData.venues.map(v => ({ id: v.id, name: v.name, type: 'Venue' }))];
    for (let i = 0; i < routeStopCounter; i++) {
        const select = document.getElementById(`routeSelect${i}`);
         const dateInput = document.getElementById(`routeDate${i}`);
        if (select) {
             // Ensure tourData.routePlannerState[i] exists before accessing
            if (!tourData.routePlannerState[i]) {
                 tourData.routePlannerState[i] = { selectValue: '', dateValue: '' };
            }
            const savedState = tourData.routePlannerState[i];

            let placeholderText = (i === 0) ? '-- Select Starting Point --' : '-- Select Next Stop --';
            select.innerHTML = `<option value="">${placeholderText}</option>`;

            allLocations.forEach(location => {
                const option = document.createElement('option');
                option.value = `${location.type}:${location.id}`;
                option.textContent = `${location.type}: ${location.name}`;
                select.appendChild(option);
            });

            // Set the value from the saved state if it's still a valid option
            if (savedState && savedState.selectValue && select.querySelector(`option[value="${savedState.selectValue}"]`)) {
                 select.value = savedState.selectValue;
            } else {
                 // If saved value is invalid or missing, clear it in the state
                 tourData.routePlannerState[i].selectValue = '';
            }

             // Set the date value
             if (dateInput && savedState && savedState.dateValue) {
                  dateInput.value = savedState.dateValue;
             } else if (dateInput) {
                 // If saved date is missing, ensure UI is clear and state is clear
                  dateInput.value = '';
                 tourData.routePlannerState[i].dateValue = '';
             }
        } else {
             // If select element doesn't exist for this index, ensure state is cleared
             if (tourData.routePlannerState[i]) {
                  tourData.routePlannerState[i].selectValue = '';
                  tourData.routePlannerState[i].dateValue = '';
             }
        }
    }
    saveRoutePlannerState(); // Save the state after potentially cleaning up invalid selections/dates
    updateAllDisplays(); // Should be called after updating selects
}


function toggleRouteBuilder() {
    const content = document.getElementById('route-builder-content');
    const arrow = document.getElementById('routeBuilderToggleArrow');
    if (content && arrow) { // Safety check
        content.classList.toggle('collapsed');
        arrow.classList.toggle('collapsed');
    }
}

// Modified generateCustomRoute to use dynamic gas calculation
async function generateCustomRoute() {
    if (isGeneratingRoute) { alert('Route generation is already in progress...'); return; }
    isGeneratingRoute = true;

    const generateBtn = document.getElementById('generateRouteBtn');
    const progressDiv = document.getElementById('routeProgress');
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    const routeResults = document.getElementById('routeResults');

    // Safety check for UI elements
    if (!generateBtn || !progressDiv || !progressFill || !progressText || !routeResults) {
         console.error("Missing required route generation UI elements.");
         alert("Error: UI elements for route generation are missing.");
         isGeneratingRoute = false;
         return;
     }


    generateBtn.disabled = true;
    generateBtn.textContent = '🔄 Generating...';
    progressDiv.style.display = 'block';
    routeResults.innerHTML = ''; // Clear previous results before generating
    progressText.textContent = 'Preparing route...';
    progressFill.style.width = '0%';

    tourData.routeCache = {}; // Clear existing cache before generating new


    try {
        const segmentsForApi = [];
        for (let i = 0; i < tourData.routePlannerState.length - 1; i++) {
            const fromStopInfo = tourData.routePlannerState[i];
            const toStopInfo = tourData.routePlannerState[i + 1];
            if (!fromStopInfo || !fromStopInfo.selectValue || !toStopInfo || !toStopInfo.selectValue) {
                 console.warn(`Skipping incomplete segment at index ${i}: Missing stop selection.`);
                 continue; // Skip if stops are not selected
             }

            const fromLocation = getLocationDetails(fromStopInfo.selectValue);
            const toLocation = getLocationDetails(toStopInfo.selectValue);

             // Skip if addresses are invalid
             if (!fromLocation || !fromLocation.address || fromLocation.address === 'N/A' || !toLocation || !toLocation.address || toLocation.address === 'N/A') {
                  console.warn(`Skipping segment at index ${i} due to invalid address: ${fromLocation.name} -> ${toLocation.name}`);
                 // Optionally, display an error message for this skipped segment
                  routeResults.innerHTML += `<div class="route-item error"><strong>Segment at planner index ${i+1} (${fromLocation.name} → ${toLocation.name}):</strong> Invalid address.</div>`;
                 continue;
             }


            segmentsForApi.push({
                 date: fromStopInfo.dateValue || 'No Date', // Date associated with the start of the segment
                 origin: fromLocation.address,
                 destination: toLocation.address,
                 fromName: fromLocation.name, // Store names for rendering
                 toName: toLocation.name,
                 toType: toLocation.type // Store type for rendering
            });
        }

        if (segmentsForApi.length === 0) {
            throw new Error('No valid or routable segments found in the route planner.');
        }

        // In the original code, you processed day-by-day. This version sends segments to the proxy.
        // Let's group segments by date to match the original rendering structure.
         const segmentsByDate = segmentsForApi.reduce((acc, segment) => {
             const date = segment.date;
             if (!acc[date]) acc[date] = [];
             acc[date].push(segment);
             return acc;
         }, {});

         const allDates = Object.keys(segmentsByDate).sort();


        let grandTotalDistanceMeters = 0, grandTotalTimeSecs = 0, grandTotalGas = 0;
        let processedSegmentsCount = 0; // For progress bar

        routeResults.innerHTML = '<h3 style="color: #ffd700; margin-bottom: 15px;">🛣️ Generated Route</h3>'; // Add main header
         // Clear and prepare routeCache for this generation
         tourData.routeCache = {};


        for (const date of allDates) {
             const segmentsForThisDate = segmentsByDate[date];
             let dayTotalDistanceMeters = 0;
             let dayTotalTimeSecs = 0;

             // For each segment on this date, fetch route data
             for (const segment of segmentsForThisDate) {
                 try {
                     const cacheKey = `${date}_${segment.origin}_${segment.destination}`;
                     const CACHE_TTL = 7200000; // 2 hours

                     let segmentRouteData;

                     if (tourData.routeCache[cacheKey] && (Date.now() - tourData.routeCache[cacheKey].timestamp < CACHE_TTL)) {
                         segmentRouteData = tourData.routeCache[cacheKey].data;
                         segmentRouteData.isCached = true;
                         console.log(`Segment cache hit for ${segment.fromName} -> ${segment.toName} on ${date}`);
                     } else {
                         console.log(`Segment cache miss for ${segment.fromName} -> ${segment.toName} on ${date}. Fetching...`);
                         const url = `https://maps-proxy-hru8.onrender.com/maps?origin=${encodeURIComponent(segment.origin)}&destination=${encodeURIComponent(segment.destination)}`;

                         const response = await fetch(url);
                         if (!response.ok) {
                             const errorBody = await response.text();
                             throw new Error(`API Load failed (status: ${response.status}) for ${segment.fromName} -> ${segment.toName}. Response: ${errorBody}`);
                         }
                         const data = await response.json();

                         if (data.status !== 'OK') {
                             const googleErrorMessage = data.status === 'ZERO_RESULTS' ? 'No route found.' : data.error_message || 'Unknown API error.';
                             throw new Error(`Google Maps Error for ${segment.fromName} -> ${segment.toName}: ${data.status}. ${googleErrorMessage}`);
                         }
                          if (!data.routes || data.routes.length === 0 || !data.routes[0].legs || data.routes[0].legs.length === 0) {
                             throw new Error(`API returned OK but no route/legs found for ${segment.fromName} -> ${segment.toName}.`);
                          }


                         // Store minimal data for the segment
                         segmentRouteData = {
                             legs: data.routes[0].legs, // Typically one leg for a direct A-B call
                             totalDistance: data.routes[0].legs.reduce((sum, leg) => sum + leg.distance.value, 0),
                             totalTime: data.routes[0].legs.reduce((sum, leg) => sum + (leg.duration_in_traffic || leg.duration).value, 0),
                             // Names/types are stored in the segment definition itself, not the cached route data in this structure
                             isCached: false
                         };

                         // Update cache
                         tourData.routeCache[cacheKey] = { data: segmentRouteData, timestamp: Date.now() };
                         saveData(); // Save the updated cache
                     }

                     // Render the segment
                     const segmentDistanceMeters = segmentRouteData.totalDistance;
                     const segmentTimeSecs = segmentRouteData.totalTime;
                     const segmentGas = calculateGasCost(segmentDistanceMeters); // Calculate dynamically

                     dayTotalDistanceMeters += segmentDistanceMeters;
                     dayTotalTimeSecs += segmentTimeSecs;
                     grandTotalGas += segmentGas; // Sum grand total gas

                     const routeSegmentEl = document.createElement('div');
                     routeSegmentEl.className = `route-item ${segmentRouteData.isCached ? 'cached' : ''} ${segment.toType === 'Venue' ? 'show-day' : ''}`;
                     routeSegmentEl.innerHTML = `
                         <div class="route-header"><strong>${segment.fromName} → ${segment.toName}</strong><span style="color: ${segmentRouteData.isCached ? '#4CAF50' : '#87CEEB'}; font-size: 10px;">✓ ${segmentRouteData.isCached ? 'CACHED' : 'REAL-TIME'}</span></div>
                         <div class="route-info">
                             <strong>Distance:</strong> ${(segmentDistanceMeters/1000).toFixed(1)} km | <strong>Time (traffic):</strong> ${Math.floor(segmentTimeSecs/3600)}h ${Math.floor((segmentTimeSecs%3600)/60)}m<br>
                             <strong>Est. Gas:</strong> $${segmentGas.toFixed(0)} CAD
                         </div>
                     `;
                     routeResults.appendChild(routeSegmentEl);


                 } catch (segmentError) {
                     console.error(`Error processing segment ${segment.fromName} -> ${segment.toName} on ${date}:`, segmentError);
                      // Render an error for this specific segment
                      routeResults.innerHTML += `<div class="route-item error"><strong>Error Segment (${segment.fromName} → ${segment.toName} on ${date}):</strong> ${segmentError.message}</div>`;
                 }
                 processedSegmentsCount++;
                 const progress = (processedSegmentsCount / segmentsForApi.length) * 100;
                 progressFill.style.width = `${progress}%`;
                 progressText.textContent = `Processing segment ${processedSegmentsCount}/${segmentsForApi.length}...`;
                 await new Promise(resolve => setTimeout(resolve, 50)); // Small delay
             } // End segment loop for date

             // Optionally, render a day summary here based on dayTotalDistanceMeters and dayTotalTimeSecs
             // The original code rendered a day summary using totalGas from the cached data,
             // but we removed that. Let's add a simple summary here.
             const dayHours = Math.floor(dayTotalTimeSecs / 3600);
             const dayMinutes = Math.floor((dayTotalTimeSecs % 3600) / 60);
             const daySummary = document.createElement('div');
             daySummary.className = 'day-summary-box';
             daySummary.innerHTML = `<h4>Day Summary (${date === 'No Date' ? 'No Date' : formatDate(date)})</h4>
                                     <div class="stats-grid stats-grid-3-col">
                                         <div class="stat-card"><div class="stat-value">${(dayTotalDistanceMeters/1000).toFixed(0)} km</div><div class="stat-label">Day Distance</div></div>
                                         <div class="stat-card"><div class="stat-value">${dayHours}h ${dayMinutes}m</div><div class="stat-label">Day Drive Time</div></div>
                                         <div class="stat-card"><div class="stat-value">$${calculateGasCost(dayTotalDistanceMeters).toFixed(0)}</div><div class="stat-label">Est. Gas</div></div>
                                     </div>`;
              // Insert day summary before the segments for that day (need to find where the first segment was added)
              const firstSegmentEl = routeResults.querySelector('.route-item'); // This is a simplified way, might not work if errors are first
              if (firstSegmentEl) {
                 routeResults.insertBefore(daySummary, firstSegmentEl);
              } else {
                 routeResults.appendChild(daySummary); // If no segments, just add summary at the end
              }


        } // End date loop


        // Update overall summary stats after all processing
        updateRouteSummaryStats();

        progressText.textContent = '✅ Route generation completed!';

    } catch (error) {
        console.error('Overall Route generation error:', error);
        routeResults.innerHTML += `<div class="route-item error"><strong>❌ Overall Route Generation Error:</strong> ${error.message}</div>`; // Append overall error
        progressText.textContent = '❌ Generation failed';
    } finally {
        isGeneratingRoute = false;
        generateBtn.disabled = false;
        generateBtn.textContent = '🛣️ Generate Full Tour Route';
        setTimeout(() => { progressDiv.style.display = 'none'; }, 3000);
    }
}

// Function to re-render cached route results on the Route tab
// Used after settings are applied or tab is shown.
function renderRouteResults() {
    const routeResults = document.getElementById('routeResults');
    if (!routeResults) return; // Safety check
    routeResults.innerHTML = ''; // Clear current display

    if (!tourData.routeCache || Object.keys(tourData.routeCache).length === 0) {
        routeResults.innerHTML = '<p style="text-align: center; color: #ccc;">Generate a route using the planner above.</p>';
        return;
    }

    routeResults.innerHTML = '<h3 style="color: #ffd700; margin-bottom: 15px;">🛣️ Generated Route</h3>'; // Add main header

    // Sort cache keys by date for ordered rendering
    const sortedCacheKeys = Object.keys(tourData.routeCache).sort();

    sortedCacheKeys.forEach(key => {
        const cacheEntry = tourData.routeCache[key];
        // Ensure the cache entry structure is valid
        if (!cacheEntry || !cacheEntry.data || !Array.isArray(cacheEntry.data.legs) || !Array.isArray(cacheEntry.data.stops) || cacheEntry.data.legs.length === 0) {
             console.warn(`Skipping invalid or empty cache entry for rendering: ${key}`, cacheEntry);
             return; // Skip this invalid entry
         }

        const dayData = cacheEntry.data; // Using dayData to match original structure naming
        const date = key.split('_')[0]; // Extract date from the cache key

        // Calculate day summary stats dynamically for rendering
        let dayTotalDistanceMeters = dayData.totalDistance || 0;
        let dayTotalTimeSecs = dayData.totalTime || 0;
        let dayTotalGas = calculateGasCost(dayTotalDistanceMeters); // Calculate dynamically


        const dayHours = Math.floor(dayTotalTimeSecs / 3600);
        const dayMinutes = Math.floor((dayTotalTimeSecs % 3600) / 60);

        const daySummary = document.createElement('div');
        daySummary.className = 'day-summary-box';
        daySummary.innerHTML = `<h4>Day Summary (${date === 'No Date' ? 'No Date' : formatDate(date)}) ${dayData.isCached ? '✓' : '✅'}</h4>
                                 <div class="stats-grid stats-grid-3-col">
                                     <div class="stat-card"><div class="stat-value">${(dayTotalDistanceMeters/1000).toFixed(0)} km</div><div class="stat-label">Day Distance</div></div>
                                     <div class="stat-card"><div class="stat-value">${dayHours}h ${dayMinutes}m</div><div class="stat-label">Day Drive Time</div></div>
                                     <div class="stat-card"><div class="stat-value">$${dayTotalGas.toFixed(0)}</div><div class="stat-label">Est. Gas</div></div>
                                 </div>`;
        routeResults.appendChild(daySummary);


        dayData.legs.forEach((leg, index) => {
            // Calculate gas cost for the segment dynamically
            const gasCost = calculateGasCost(leg.distance.value);
            // Get from/to stops from the cached stops array
             const fromStop = dayData.stops[index] || { name: 'Unknown From', type: 'Unknown' };
             const toStop = dayData.stops[index+1] || { name: 'Unknown To', type: 'Unknown' };

            const routeSegment = document.createElement('div');
            routeSegment.className = `route-item ${dayData.isCached ? 'cached' : ''} ${toStop.type === 'Venue' ? 'show-day' : ''}`;
            routeSegment.innerHTML = `<div class="route-header"><strong>${fromStop.name ?? 'N/A'} → ${toStop.name ?? 'N/A'}</strong><span style="color: ${dayData.isCached ? '#4CAF50' : '#87CEEB'}; font-size: 10px;">✓ ${dayData.isCached ? 'CACHED' : 'REAL-TIME'}</span></div><div class="route-info"><strong>Distance:</strong> ${leg.distance.text} | <strong>Time (traffic):</strong> ${(leg.duration_in_traffic || leg.duration).text}<br><strong>Est. Gas:</strong> $${gasCost.toFixed(0)} CAD</div>`;
            routeResults.appendChild(routeSegment);
        });
    });
}

// Modified updateRouteSummaryStats to use dynamic gas calculation
function updateRouteSummaryStats() {
    let grandTotalDistanceMeters = 0;
    let grandTotalTimeSecs = 0;
    let grandTotalGas = 0;

    // Ensure routeCache exists and is an object
    if (!tourData.routeCache || typeof tourData.routeCache !== 'object') {
        tourData.routeCache = {}; // Reset if invalid
    }

    // Iterate through ALL cached entries (sequences) to sum totals
    Object.values(tourData.routeCache).forEach(cacheEntry => {
        // Ensure cache entry is valid before processing
         if (!cacheEntry || !cacheEntry.data || !Array.isArray(cacheEntry.data.legs)) {
              console.warn(`Skipping invalid cache entry in stats:`, cacheEntry);
              return; // Skip this invalid entry
         }
        const dayData = cacheEntry.data; // Using dayData to match original structure naming
         // Sum distances and times directly from cached values
        grandTotalDistanceMeters += dayData.totalDistance || 0;
        grandTotalTimeSecs += dayData.totalTime || 0;
         // Sum gas costs per leg dynamically using current settings
        dayData.legs.forEach(leg => {
            grandTotalGas += calculateGasCost(leg.distance.value);
        });
    });

    const totalHours = Math.floor(grandTotalTimeSecs / 3600);
    const totalMinutes = Math.floor((grandTotalTimeSecs % 3600) / 60);

     // Update the UI elements
    const totalDistanceStat = document.getElementById('totalDistanceStat');
    const totalTimeStat = document.getElementById('totalTimeStat');
    const totalGasStat = document.getElementById('totalGasStat');

    if (totalDistanceStat) totalDistanceStat.textContent = `${(grandTotalDistanceMeters/1000).toFixed(0)} km`;
    if (totalTimeStat) totalTimeStat.textContent = `${totalHours}h ${totalMinutes}m`;
    if (totalGasStat) totalGasStat.textContent = '$' + grandTotalGas.toFixed(0);
}


function renderErrorDay(date, dayCounter, errorMessage) {
    const routeResults = document.getElementById('routeResults');
     if (!routeResults) return; // Safety check
    const errorSummary = document.createElement('div');
    errorSummary.className = 'day-summary-box';
    errorSummary.style.borderColor = '#e74c3c';
    errorSummary.innerHTML = `<h4>Day ${dayCounter} (${date === 'No Date' ? 'No Date' : formatDate(date)}) ❌</h4><div class="route-item error"><strong>Error:</strong> ${errorMessage}</div>`;
    routeResults.appendChild(errorSummary);
}


// --- Calendar Logic ---
function renderCalendar() {
    const calendarEl = document.getElementById('calendar-grid');
    const monthYearEl = document.getElementById('month-year');
    if (!calendarEl || !monthYearEl) return; // Safety checks
    calendarEl.innerHTML = '';
    const firstDay = new Date(currentYear, currentMonth, 1).getDay(); // 0 = Sunday, 6 = Saturday
    const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
    const daysInPrevMonth = new Date(currentYear, currentMonth, 0).getDate();

    monthYearEl.textContent = `${new Date(currentYear, currentMonth).toLocaleString('default', { month: 'long' })} ${currentYear}`;

    // Add days from previous month to fill the first week
    for (let i = firstDay - 1; i >= 0; i--) {
         const prevMonthDay = daysInPrevMonth - i;
         const prevMonthDate = new Date(currentYear, currentMonth - 1, prevMonthDay);
         const dateStr = prevMonthDate.toISOString().split('T')[0];
          calendarEl.innerHTML += `<div class="calendar-day other-month" onclick="showDayDetails('${dateStr}')"><div class="day-number">${prevMonthDay}</div></div>`;
    }

    // Add days for the current month
    for (let day = 1; day <= daysInMonth; day++) {
        const dateStr = `${currentYear}-${String(currentMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
        let dayHtml = `<div class="calendar-day" onclick="showDayDetails('${dateStr}')"><div class="day-number">${day}</div>`;

        const events = getEventsForDate(dateStr);
        let eventIcons = '';

        // --- CALENDAR ICON LOGIC (Priority: Venue > Travel > None) ---
        if (events.isVenue) {
             eventIcons = '🎵';
        } else if (events.isTravel) {
             eventIcons = '🚗';
        }
        // No hotel icon on the main calendar grid as per user request

        dayHtml += `<div class="day-events">${eventIcons}</div>`;

        // Add static notes (adjust dates as needed)
        if (dateStr === '2025-07-08') dayHtml += `<div class="day-note">🎂 My Birthday!</div>`;
        if (dateStr === '2025-07-16') dayHtml += `<div class="day-note">Break at Home</div>`;

        // Add other notes ONLY if no icon and not a fixed note day
         if (!events.isVenue && !events.isTravel && dateStr !== '2025-07-08' && dateStr !== '2025-07-16' && day % 10 === 0) {
             dayHtml += `<div class="day-note">Keep it up!</div>`;
         }


        dayHtml += '</div>';
        calendarEl.innerHTML += dayHtml;
    }

     // Add days from next month to fill the grid
    const totalDaysDisplayed = calendarEl.children.length; // Count the elements already added
    const remainingSlots = 42 - totalDaysDisplayed; // Max slots needed for 6 full weeks
    if (remainingSlots > 0) {
         for (let i = 1; i <= remainingSlots; i++) {
            const nextMonthDate = new Date(currentYear, currentMonth + 1, i);
            const dateStr = nextMonthDate.toISOString().split('T')[0];
             // Use other-month class and add click handler
             calendarEl.innerHTML += `<div class="calendar-day other-month" onclick="showDayDetails('${dateStr}')"><div class="day-number">${i}</div></div>`;
         }
    }
}

 // Determines what kind of events happen on a given date (for calendar icon logic)
 function getEventsForDate(dateStr) {
     let isVenue = tourData.venues.some(v => v.date === dateStr);

     // Check route planner & cache for travel days
     let isTravel = false;

     // A day is a travel day if its date is the *start date* of any cached route sequence with legs
     // or if it falls within the date range of a multi-day cached route sequence.
     Object.keys(tourData.routeCache).forEach(key => {
          const cacheDayStartDateStr = key.split('_')[0];
          // Ensure cache entry and data are valid and represent a route
           const cacheEntry = tourData.routeCache[key];
           if (!cacheEntry || !cacheEntry.data || !Array.isArray(cacheEntry.data.legs) || cacheEntry.data.legs.length === 0 || !Array.isArray(cacheEntry.data.stops) || cacheEntry.data.stops.length < 2) {
                return; // Skip invalid cache entry
           }
           const sequenceData = cacheEntry.data;

           // Find the date for the LAST stop in the cached sequence (by looking up the stop ID in planner state)
           let cacheDayEndDateStr = null;
            if (Array.isArray(tourData.routePlannerState)) { // Ensure plannerState is an array
               const lastStopInSequence = sequenceData.stops[sequenceData.stops.length - 1];
               // Make sure lastStopInSequence has type and id before building string
               if (lastStopInSequence && lastStopInSequence.type && lastStopInSequence.id != null) {
                   const lastStopId = lastStopInSequence.type + ':' + lastStopInSequence.id;
                   const lastStopPlannerEntry = tourData.routePlannerState.find(r => r.selectValue === lastStopId);
                   if (lastStopPlannerEntry && lastStopPlannerEntry.dateValue) {
                       cacheDayEndDateStr = lastStopPlannerEntry.dateValue;
                   }
               }
          }


          if (cacheDayStartDateStr && cacheDayEndDateStr) {
               const cacheStart = new Date(cacheDayStartDateStr + 'T00:00:00');
               const cacheEnd = new Date(cacheDayEndDateStr + 'T00:00:00');
               const current = new Date(dateStr + 'T00:00:00');

               // If the current date is within the range [cacheStart, cacheEnd] inclusive
               if (current >= cacheStart && current <= cacheEnd) {
                   isTravel = true; // It's a travel day covered by cache
               }
          }
     });

    return { isVenue, isTravel }; // Return only Venue and Travel status
}


// Shows modal with details for a specific date
function showDayDetails(dateStr) {
    const modal = document.getElementById('calendarModal');
    const content = document.getElementById('calendarModalContent');
    if (!modal || !content) {
         console.error("Calendar modal or content element not found!");
         return; // Cannot show modal if elements are missing
    }


    const venuesOnDay = tourData.venues.filter(v => v.date === dateStr);
    const hotelsOnDay = tourData.hotels.filter(h => {
         if (h.checkin && h.checkout) {
             const checkin = new Date(h.checkin + 'T00:00:00');
             const checkout = new Date(h.checkout + 'T00:00:00');
             const currentDate = new Date(dateStr + 'T00:00:00');
             return currentDate >= checkin && currentDate <= checkout;
         }
         return false;
    });

    let html = `<div class="modal-header">
                    <button class="modal-nav prev" onclick="showPrevDay()">◄</button>
                    <div>Details for ${formatDate(dateStr)}</div>
                    <button class="modal-nav next" onclick="showNextDay()">►</button>
                    <span class="close" onclick="closeModal('calendarModal')">&times;</span>
                </div>`;

    if (venuesOnDay.length > 0) { html += `<h3>🎵 Venues</h3>` + venuesOnDay.map(v => `<div class="route-item venue-card" style="cursor:default; border-left-color:#ffd700;">${v.name ?? 'N/A'} @ ${formatTime(v.time)}<br><small>${v.address ? v.address.substring(0, 50) + (v.address.length > 50 ? '...' : '') : 'N/A'}</small></div>`).join(''); }
    if (hotelsOnDay.length > 0) { html += `<h3>🏨 Hotels</h3>` + hotelsOnDay.map(h => `<div class="route-item hotel-card" style="cursor:default; border-left-color:#87CEEB;">${h.name ?? 'N/A'}<br><small>Check-in: ${formatDate(h.checkin)} | Check-out: ${formatDate(h.checkout)}</small></div>`).join(''); }


    // Find cached route data sequences that *include* this date as part of their sequence range.
     const relevantCachedSequenceKeys = Object.keys(tourData.routeCache).filter(key => {
        const cacheDayStartDateStr = key.split('_')[0];
        // Ensure cache entry and data are valid
        if (!tourData.routeCache[key] || !tourData.routeCache[key].data || !Array.isArray(tourData.routeCache[key].data.legs) || !Array.isArray(tourData.routeCache[key].data.stops) || tourData.routeCache[key].data.legs.length === 0 || tourData.routeCache[key].data.stops.length < 2) {
             return false; // Skip invalid cache entry
        }
         const sequenceData = tourData.routeCache[key].data;

        // Find the date for the LAST stop in the cached sequence (by looking up the stop ID in planner state)
         let cacheDayEndDateStr = null;
          if (Array.isArray(tourData.routePlannerState)) { // Ensure plannerState is an array
             const lastStopInSequence = sequenceData.stops[sequenceData.stops.length - 1];
             // Make sure lastStopInSequence has type and id before building string
             if (lastStopInSequence && lastStopInSequence.type && lastStopInSequence.id != null) {
                 const lastStopId = lastStopInSequence.type + ':' + lastStopInSequence.id;
                 const lastStopPlannerEntry = tourData.routePlannerState.find(r => r.selectValue === lastStopId);
                 if (lastStopPlannerEntry && lastStopPlannerEntry.dateValue) {
                     cacheDayEndDateStr = lastStopPlannerEntry.dateValue;
                 }
             }
        }


         if (cacheDayStartDateStr && cacheDayEndDateStr) {
             const cacheStart = new Date(cacheDayStartDateStr + 'T00:00:00');
             const cacheEnd = new Date(cacheDayEndDateStr + 'T00:00:00');
             const current = new Date(dateStr + 'T00:00:00');

             // Check if the current date is within the range [cacheStart, cacheEnd] inclusive
             return current >= cacheStart && current <= cacheEnd;
         }
         return false; // Cannot determine range if dates are missing
    }).sort(); // Sort keys to display routes in chronological order by start date

    if (relevantCachedSequenceKeys.length > 0) {
         html += `<h3>🚗 Travel Information</h3>`; // General header for travel info on this date

         relevantCachedSequenceKeys.forEach((key, index) => {
             const cacheEntry = tourData.routeCache[key];
             const sequenceData = cacheEntry.data; // Already checked for validity in filter
             const cacheDayStartDateStr = key.split('_')[0];

             const sequenceHours = Math.floor(sequenceData.totalTime / 3600);
             const sequenceMinutes = Math.floor((sequenceData.totalTime % 3600) / 60);
             const sequenceTotalGas = calculateGasCost(sequenceData.totalDistance); // Dynamic gas calc

              // Display a summary for this specific sequence
              // Use index + 1 as the sequence counter within the modal list for this day
              html += `<h4>Route Sequence ${index + 1} Starting ${formatDate(cacheDayStartDateStr)} (${sequenceData.isCached ? 'Cached' : 'Real-time'})</h4>
                     <div class="day-summary-box" style="margin-top:0;">
                        <div class="stats-grid stats-grid-3-col" style="margin-bottom:0;">
                            <div class="stat-card"><div class="stat-value">${(sequenceData.totalDistance/1000).toFixed(0)} km</div><div class="stat-label">Seq. Distance</div></div>
                            <div class="stat-card"><div class="stat-value">${sequenceHours}h ${sequenceMinutes}m</div><div class="stat-label">Seq. Drive Time</div></div>
                            <div class="stat-card"><div class="stat-value">$${sequenceTotalGas.toFixed(0)}</div><div class="stat-label">Est. Gas</div></div>
                        </div>
                     </div>
                     <h4>Segments for this Route Sequence</h4>`; // Changed to Segments as it lists legs


               // Display segments (legs) from the cached sequence data
               sequenceData.legs.forEach((leg, legIndex) => {
                    const gasCost = calculateGasCost(leg.distance.value); // Dynamic gas calc
                    const fromStop = sequenceData.stops[legIndex] || { name: 'Unknown From', type: 'Unknown' };
                    const toStop = sequenceData.stops[legIndex + 1] || { name: 'Unknown To', type: 'Unknown' };
                     html += `<div class="route-item" style="border-left-color:${sequenceData.isCached ? '#4CAF50' : '#87CEEB'};">
                                 <strong>${fromStop.name ?? 'N/A'} → ${toStop.name ?? 'N/A'}</strong>
                                 <br><small>Distance: ${leg.distance.text} | Time: ${(leg.duration_in_traffic || leg.duration).text} | Est. Gas: $${gasCost.toFixed(0)}</small>
                                 </div>`;
                });
         });

    }


    // Check if any events were displayed
    const hasEvents = venuesOnDay.length > 0 || hotelsOnDay.length > 0 || relevantCachedSequenceKeys.length > 0;
     if (!hasEvents) {
         html += `<p style="text-align:center; padding: 20px;">No events scheduled for this day.</p>`;
    }


    content.innerHTML = html;
    modal.style.display = 'block';
    currentModalDate = dateStr;
    addSwipeListeners(modal);
}


function showPrevDay() {
    if (!currentModalDate) return;
    let date = new Date(currentModalDate + 'T12:00:00Z'); // Use midday to avoid timezone issues with date arithmetic
    date.setDate(date.getDate() - 1);
    showDayDetails(date.toISOString().split('T')[0]);
}

function showNextDay() {
    if (!currentModalDate) return;
    let date = new Date(currentModalDate + 'T12:00:00Z'); // Use midday
    date.setDate(date.getDate() + 1);
    showDayDetails(date.toISOString().split('T')[0]);
}

let touchstartX = 0;
let touchendX = 0;
function handleSwipe() {
     // Allow swipe only if the modal content itself is NOT scrollable
     const modalContentEl = document.getElementById('calendarModalContent');
     // Check if the modal content height exceeds its container height (allowing scroll)
     const isContentScrollable = modalContentEl && modalContentEl.scrollHeight > modalContentEl.clientHeight; // Add null check

     if (!isContentScrollable) {
        if (touchendX < touchstartX - 50) showNextDay();
        if (touchendX > touchstartX + 50) showPrevDay();
     } else {
         // If content is scrollable, regular touch/scroll behavior is expected.
     }
 }

function addSwipeListeners(element) {
     if (!element) return; // Safety check
    // Ensure listeners are not duplicated by removing them first
    const handleTouchStart = (e) => { touchstartX = e.changedTouches[0].screenX; };
    const handleTouchEnd = (e) => { touchendX = e.changedTouches[0].screenX; handleSwipe(); };

    // Removing and re-adding ensures only one set of listeners is active when modal is shown
    element.removeEventListener('touchstart', handleTouchStart, {passive: true});
    element.removeEventListener('touchend', handleTouchEnd, {passive: true});

    element.addEventListener('touchstart', handleTouchStart, {passive: true});
    element.addEventListener('touchend', handleTouchEnd, {passive: true});
}


function prevMonth() { currentMonth--; if (currentMonth < 0) { currentMonth = 11; currentYear--; } renderCalendar(); }
function nextMonth() { currentMonth++; if (currentMonth > 11) { currentMonth = 0; currentYear++; } renderCalendar(); }


// --- Modal Edit Functions ---
function openHotelModal(hotelId) {
    console.log("Attempting to open hotel modal for ID:", hotelId);
    const hotel = tourData.hotels.find(h => h.id === hotelId);
    if (!hotel) {
        console.error("Hotel not found for editing:", hotelId);
        alert("Error: Hotel data not found for editing.");
        return;
    }
    currentEditId = hotelId;
    // Populate form - IMPORTANT: Check if the modal elements exist BEFORE setting values
    const modal = document.getElementById('hotelModal');
    if (!modal) {
         console.error("Hotel modal HTML structure not found!");
         alert("Error: Cannot open edit form.");
         return;
    }
    // Get all input elements within the modal form
    const nameInput = document.getElementById('editHotelName');
    const addressInput = document.getElementById('editHotelAddress');
    const checkinInput = document.getElementById('editCheckinDate');
    const checkoutInput = document.getElementById('editCheckoutDate');
    const usdInput = document.getElementById('editHotelCostUSD');
    const cadInput = document.getElementById('editHotelCostCAD');
    const notesInput = document.getElementById('editHotelNotes');

    // Check if all necessary input elements are found
    if (!nameInput || !addressInput || !checkinInput || !checkoutInput || !usdInput || !cadInput || !notesInput) {
         console.error("One or more hotel modal form elements not found!");
         // Alert might be disruptive, just log the error and return
         return; // Cannot populate form if elements are missing
    }


    // Use nullish coalescing (??) to provide default empty values for inputs
    nameInput.value = hotel.name ?? '';
    addressInput.value = hotel.address ?? '';
    checkinInput.value = hotel.checkin ?? '';
    checkoutInput.value = hotel.checkout ?? '';
    usdInput.value = hotel.costUSD ?? 0;
    cadInput.value = hotel.costCAD ?? 0; // Populate manual CAD if present
    notesInput.value = hotel.notes ?? '';

    modal.style.display = 'block';
     console.log("Hotel modal opened for ID:", hotelId);
}
function openVenueModal(venueId) {
     console.log("Attempting to open venue modal for ID:", venueId);
     const venue = tourData.venues.find(v => v.id === venueId);
     if (!venue) {
         console.error("Venue not found for editing:", venueId);
         alert("Error: Venue data not found for editing.");
         return;
     }
     currentEditId = venueId;
     // Populate form - IMPORTANT: Check if the modal elements exist BEFORE setting values
     const modal = document.getElementById('venueModal');
     if (!modal) {
          console.error("Venue modal HTML structure not found!");
          alert("Error: Cannot open edit form.");
          return;
     }
      // Get all input elements within the modal form
     const nameInput = document.getElementById('editVenueName');
     const addressInput = document.getElementById('editVenueAddress');
     const dateInput = document.getElementById('editShowDate');
     const timeInput = document.getElementById('editShowTime');
     const startInvInput = document.getElementById('editStartInventory');
     const endInvInput = document.getElementById('editEndInventory');
     const salesInput = document.getElementById('editTotalSales');
     const notesInput = document.getElementById('editVenueNotes');

     // Check if all necessary input elements are found
      if (!nameInput || !addressInput || !dateInput || !timeInput || !startInvInput || !endInvInput || !salesInput || !notesInput) {
           console.error("One or more venue modal form elements not found!");
           return; // Cannot populate form if elements are missing
      }


     // Use nullish coalescing (??)
     nameInput.value = venue.name ?? '';
     addressInput.value = venue.address ?? '';
     dateInput.value = venue.date ?? '';
     timeInput.value = venue.time ?? '';
     startInvInput.value = venue.startInventory ?? 0;
     endInvInput.value = venue.endInventory ?? 0;
     salesInput.value = venue.totalSales ?? 0;
     notesInput.value = venue.notes ?? '';

     modal.style.display = 'block';
     console.log("Venue modal opened for ID:", venueId);
 }

function closeModal(modalId) {
     const modal = document.getElementById(modalId);
     if (modal) {
          modal.style.display = 'none';
          currentEditId = null; // Clear edit ID on close
          console.log("Modal closed:", modalId);
     }
}

function saveHotelEdit() {
    console.log("Attempting to save hotel edit for ID:", currentEditId);
    const hotelIndex = tourData.hotels.findIndex(h => h.id === currentEditId);
    if (hotelIndex === -1) {
         console.error("Hotel not found for saving:", currentEditId);
         alert("Error: Hotel data not found for saving.");
         return;
    }

    // Get input elements from modal form
    const nameInput = document.getElementById('editHotelName');
    const addressInput = document.getElementById('editHotelAddress');
    const checkinInput = document.getElementById('editCheckinDate');
    const checkoutInput = document.getElementById('editCheckoutDate');
    const usdInput = document.getElementById('editHotelCostUSD');
    const cadInput = document.getElementById('editHotelCostCAD');
    const notesInput = document.getElementById('editHotelNotes');

     if (!nameInput || !addressInput || !checkinInput || !checkoutInput || !usdInput || !cadInput || !notesInput) {
          console.error("Hotel modal form elements not found during save!");
          alert("Error: Cannot save, form elements missing.");
          return;
     }

    const editedHotel = tourData.hotels[hotelIndex]; // Reference to the actual object in the array
    editedHotel.name = nameInput.value.trim();
    editedHotel.address = addressInput.value.trim();
    editedHotel.checkin = checkinInput.value;
    editedHotel.checkout = checkoutInput.value;
    editedHotel.costUSD = parseFloat(usdInput.value) || 0;
    editedHotel.costCAD = parseFloat(cadInput.value) || 0;
    editedHotel.notes = notesInput.value.trim();

    // Basic validation again on save
     if (!editedHotel.name || !editedHotel.address || !editedHotel.checkin) {
         alert('Please fill in hotel name, full address, and check-in date.');
         return;
     }
     if (editedHotel.checkout && new Date(editedHotel.checkin) > new Date(editedHotel.checkout)) {
          alert('Check-out date cannot be before check-in date.');
          return;
     }

    saveData(); // Save changes
    updateAllDisplays(); // Refresh UI
    closeModal('hotelModal');
     console.log("Hotel edit saved for ID:", currentEditId);
}

function saveVenueEdit() {
     console.log("Attempting to save venue edit for ID:", currentEditId);
     const venueIndex = tourData.venues.findIndex(v => v.id === currentEditId);
     if (venueIndex === -1) {
         console.error("Venue not found for saving:", currentEditId);
         alert("Error: Venue data not found for saving.");
         return;
     }

     // Get input elements from modal form
     const nameInput = document.getElementById('editVenueName');
     const addressInput = document.getElementById('editVenueAddress');
     const dateInput = document.getElementById('editShowDate');
     const timeInput = document.getElementById('editShowTime');
     const startInvInput = document.getElementById('editStartInventory');
     const endInvInput = document.getElementById('editEndInventory');
     const salesInput = document.getElementById('editTotalSales');
     const notesInput = document.getElementById('editVenueNotes');

      if (!nameInput || !addressInput || !dateInput || !timeInput || !startInvInput || !endInvInput || !salesInput || !notesInput) {
           console.error("Venue modal form elements not found during save!");
           alert("Error: Cannot save, form elements missing.");
           return;
      }

     const editedVenue = tourData.venues[venueIndex]; // Reference to the actual object in the array
     editedVenue.name = nameInput.value.trim();
     editedVenue.address = addressInput.value.trim();
     editedVenue.date = dateInput.value;
     editedVenue.time = timeInput.value;
     editedVenue.startInventory = parseInt(startInvInput.value) || 0;
     editedVenue.endInventory = parseInt(endInvInput.value) || 0;
     editedVenue.totalSales = parseFloat(salesInput.value) || 0;
     editedVenue.notes = notesInput.value.trim();

     // Basic validation on save
     if (!editedVenue.name || !editedVenue.address || !editedVenue.date) {
          alert('Please fill in venue name, full address, and show date.');
          return;
     }


     saveData(); // Save changes
     updateAllDisplays(); // Refresh UI
     closeModal('venueModal');
     console.log("Venue edit saved for ID:", currentEditId);
}

// Delete function specific for modals (uses currentEditId)
 function deleteHotel() {
     if (confirm('Are you sure you want to delete this hotel? This cannot be undone!')) {
          console.log("Attempting to delete hotel ID:", currentEditId);
         tourData.hotels = tourData.hotels.filter(h => h.id !== currentEditId);
         // Also remove this hotel from route planner if it's used
          tourData.routePlannerState = tourData.routePlannerState.map(stop =>
               stop.selectValue === `Hotel:${currentEditId}` ? { selectValue: '', dateValue: stop.dateValue } : stop
          ).filter(stop => stop.selectValue !== ''); // Remove empty stops resulting from deletion if desired
           // Ensure at least one empty stop remains if the list becomes empty
          if (tourData.routePlannerState.length === 0) {
               tourData.routePlannerState = [{ selectValue: '', dateValue: '' }];
               routeStopCounter = 1; // Reset counter
           } else {
                routeStopCounter = tourData.routePlannerState.length; // Update counter
           }

         saveData(); // Save changes
         updateAllDisplays(); // Refresh UI
         closeModal('hotelModal');
         console.log("Hotel deleted ID:", currentEditId);
     }
 }

// Delete function specific for modals (uses currentEditId)
 function deleteVenue() {
      if (confirm('Are you sure you want to delete this venue? This cannot be undone!')) {
          console.log("Attempting to delete venue ID:", currentEditId);
          tourData.venues = tourData.venues.filter(v => v.id !== currentEditId);
          // Also remove this venue from route planner if it's used
           tourData.routePlannerState = tourData.routePlannerState.map(stop =>
               stop.selectValue === `Venue:${currentEditId}` ? { selectValue: '', dateValue: stop.dateValue } : stop
           ).filter(stop => stop.selectValue !== ''); // Remove empty stops resulting from deletion if desired
           // Ensure at least one empty stop remains if the list becomes empty
           if (tourData.routePlannerState.length === 0) {
                tourData.routePlannerState = [{ selectValue: '', dateValue: '' }];
                routeStopCounter = 1; // Reset counter
            } else {
                 routeStopCounter = tourData.routePlannerState.length; // Update counter
            }

          saveData(); // Save changes
          updateAllDisplays(); // Refresh UI
          closeModal('venueModal');
          console.log("Venue deleted ID:", currentEditId);
      }
  }


// --- Display Functions (Keeping original structure using innerHTML) ---

function updateHotelsDisplay() {
    const hotelsList = document.getElementById('hotelsList');
    if (!hotelsList) return; // Safety check
    hotelsList.innerHTML = ''; // Clear current list

    const sortedHotels = [...tourData.hotels].sort((a, b) => new Date(a.checkin) - new Date(b.checkin));
    let totalCAD = 0;
    let totalNights = 0;

    sortedHotels.forEach(hotel => {
        const displayCAD = hotel.costCAD > 0 ? hotel.costCAD : (hotel.costUSD * 1.35);
        totalCAD += displayCAD;

         if (hotel.checkin && hotel.checkout) {
             const checkin = new Date(hotel.checkin + 'T00:00:00'); // Use T00:00:00 for consistent day start
             const checkout = new Date(hotel.checkout + 'T00:00:00');
             if (checkout >= checkin) {
                  const diffTime = checkout.getTime() - checkin.getTime();
                  totalNights += Math.ceil(diffTime / (1000 * 60 * 60 * 24)); // Difference in days = number of nights
             }
         }

        const cadClass = hotel.costCAD > 0 ? 'manual-cad' : 'approx-cad';

        // Use onclick attributes directly in the generated HTML string (as in original code)
        const hotelCardHtml = `
            <div class="hotel-card" onclick="openHotelModal(${hotel.id})">
                <div class="card-header">
                    <strong class="card-title">${hotel.name ?? 'N/A'}</strong>
                    <small class="card-date">${formatDate(hotel.checkin)} - ${formatDate(hotel.checkout)}</small>
                </div>
                <div style="color: #ccc; font-size: 12px; margin-bottom: 8px;">📍 ${hotel.address ? hotel.address.substring(0, 50) + (hotel.address.length > 50 ? '...' : '') : 'N/A'}</div>
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span>USD: ${(hotel.costUSD ?? 0).toFixed(0)} | <span class="${cadClass}">CAD: ${displayCAD.toFixed(0)}${hotel.costCAD === 0 ? '*' : ''}</span></span>
                    <button class="btn btn-small btn-danger" onclick="event.stopPropagation(); deleteItem('hotel', ${hotel.id})">×</button>
                </div>
                ${hotel.notes ? `<div style="margin-top: 8px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px; font-size: 11px;">📝 ${hotel.notes}</div>` : ''}
            </div>
        `;
        hotelsList.innerHTML += hotelCardHtml; // Append HTML string
    });


    const hotelCountStat = document.getElementById('hotelCountStat');
    const hotelDaysStat = document.getElementById('hotelDaysStat');
    const hotelCostStat = document.getElementById('hotelCostStat');

    if (hotelCountStat) hotelCountStat.textContent = tourData.hotels.length;
    if (hotelDaysStat) hotelDaysStat.textContent = Math.round(totalNights);
    if (hotelCostStat) hotelCostStat.textContent = '$' + totalCAD.toFixed(0);
}


function updateExpensesDisplay() {
    const tbody = document.getElementById('expensesBody');
    if (!tbody) return; // Safety check
    tbody.innerHTML = ''; // Clear current rows

    let totalCAD = 0;
    const sortedExpenses = [...tourData.expenses].sort((a, b) => new Date(a.date) - new Date(b.date));

    sortedExpenses.forEach(expense => {
        const displayCAD = expense.amountCAD > 0 ? expense.amountCAD : (expense.amountUSD * 1.35);
        totalCAD += displayCAD;

        // Use innerHTML for row creation (as in original code)
        const row = tbody.insertRow();
        const cadClass = expense.amountCAD > 0 ? 'manual-cad' : 'approx-cad';
         row.innerHTML = `
             <td>${formatDate(expense.date)}</td>
             <td>${expense.type ?? 'N/A'}</td>
             <td>${(expense.location || 'N/A').substring(0, 15)}${(expense.location || '').length > 15 ? '...' : ''}</td>
             <td>${(expense.amountUSD ?? 0).toFixed(0)}</td>
             <td class="${cadClass}">${displayCAD.toFixed(0)}${expense.amountCAD === 0 ? '*' : ''}</td>
             <td><button class="btn btn-small btn-danger" onclick="event.stopPropagation(); deleteItem('expense', ${expense.id})">×</button></td>
         `;
    });

    const expenseCountStat = document.getElementById('expenseCountStat');
    const expenseCostStat = document.getElementById('expenseCostStat');
     if (expenseCountStat) expenseCountStat.textContent = tourData.expenses.length;
     if (expenseCostStat) expenseCostStat.textContent = '$' + totalCAD.toFixed(0);
}


function updateVenuesDisplay() {
    const venuesList = document.getElementById('venuesList');
    if (!venuesList) return; // Safety check
    venuesList.innerHTML = ''; // Clear current list

    const sortedVenues = [...tourData.venues].sort((a, b) => new Date(a.date) - new Date(b.date));
    let totalSales = 0;

    sortedVenues.forEach(venue => {
        totalSales += venue.totalSales;
        const soldItems = (venue.startInventory != null && venue.endInventory != null) ? (parseInt(venue.startInventory) || 0) - (parseInt(venue.endInventory) || 0) : 'N/A';

         // Use onclick attributes directly in the generated HTML string (as in original code)
        const venueCardHtml = `
            <div class="venue-card" onclick="openVenueModal(${venue.id})">
                <div class="card-header">
                    <strong class="card-title">${venue.name ?? 'N/A'}</strong>
                    <small class="card-date">${formatDate(venue.date)} @ ${formatTime(venue.time)}</small>
                </div>
                <div style="color: #ccc; font-size: 12px; margin-bottom: 8px;">📍 ${venue.address ? venue.address.substring(0, 50) + (venue.address.length > 50 ? '...' : '') : 'N/A'}</div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <span style="font-size: 12px;">Inventory: Start ${venue.startInventory ?? 'N/A'} | End ${venue.endInventory ?? 'N/A'} | Sold ${soldItems}</span>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span style="color: #4CAF50; font-weight: bold;">Sales: ${(venue.totalSales ?? 0).toLocaleString()} USD</span>
                    <button class="btn btn-small btn-danger" onclick="event.stopPropagation(); deleteItem('venue', ${venue.id})">×</button>
                </div>
                ${venue.notes ? `<div style="margin-top: 8px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px; font-size: 11px;">📝 ${venue.notes}</div>` : ''}
            </div>
        `;
        venuesList.innerHTML += venueCardHtml; // Append HTML string

    });

    const venueCountStat = document.getElementById('venueCountStat');
    const venueSalesStat = document.getElementById('venueSalesStat');
    if (venueCountStat) venueCountStat.textContent = tourData.venues.length;
    if (venueSalesStat) venueSalesStat.textContent = '$' + totalSales.toLocaleString();
}


window.onclick = function(event) {
     // Check if the click is directly on the modal backdrop, not inside the modal content
     if (event.target === document.getElementById('hotelModal')) closeModal('hotelModal');
     if (event.target === document.getElementById('venueModal')) closeModal('venueModal');
     if (event.target === document.getElementById('calendarModal')) closeModal('calendarModal');
}

function exportTourData() {
    const includeHotels = document.getElementById('exportHotels').checked;
    const includeVenues = document.getElementById('exportVenues').checked;
    const includeExpenses = document.getElementById('exportExpenses').checked;
    const includeRoute = document.getElementById('exportRoute').checked;
    let csvData = [['Category', 'Date', 'Name/Info', 'Location/Address', 'Amount', 'Currency', 'Notes']];

    if(includeHotels) tourData.hotels.forEach(h => {
        const displayCAD = h.costCAD > 0 ? h.costCAD : (h.costUSD * 1.35);
        csvData.push(['Hotel', h.checkin || 'N/A', h.name || 'N/A', h.address || 'N/A', displayCAD.toFixed(2), 'CAD (Estimate if not Manual)', `Check-out: ${h.checkout || 'N/A'} | ${h.notes || ''}`]);
    });
    if(includeVenues) tourData.venues.forEach(v => {
         const soldItems = (v.startInventory != null && v.endInventory != null) ? (parseInt(v.startInventory) || 0) - (parseInt(v.endInventory) || 0) : 'N/A';
         csvData.push(['Venue', v.date || 'N/A', v.name || 'N/A', v.address || 'N/A', v.totalSales ?? 0, 'USD', `Time: ${v.time || 'N/A'} | Sold: ${soldItems} | ${v.notes || ''}`]);
    });
    if(includeExpenses) tourData.expenses.forEach(e => {
        const displayCAD = e.amountCAD > 0 ? e.amountCAD : (e.amountUSD * 1.35);
         csvData.push(['Expense', e.date || 'N/A', e.type || 'N/A', e.location || 'N/A', displayCAD.toFixed(2), 'CAD (Estimate if not Manual)', e.notes || '']);
    });

    if (includeRoute) {
        csvData.push(['---','---','---','---','---','---','---']);
        csvData.push(['ROUTE ITINERARY', 'Date', 'From', 'To', 'Distance', 'Time', 'Est. Gas (CAD)']);
        // Sort cache keys by date for ordered export
        Object.keys(tourData.routeCache).sort().forEach(key => {
            const dayData = tourData.routeCache[key].data;
            const date = key.split('_')[0];
            dayData.legs.forEach((leg, index) => {
                const fromStop = dayData.stops[index];
                const toStop = dayData.stops[index+1];
                const legKm = leg.distance.value / 1000;
                // Calculate gas dynamically for export
                const gasCost = calculateGasCost(leg.distance.value);

                csvData.push(['Segment', date, fromStop.name || 'N/A', toStop.name || 'N/A', leg.distance.text, (leg.duration_in_traffic || leg.duration).text, gasCost.toFixed(2)]);
            });
        });
    }

    const csv = csvData.map(row => row.map(cell => {
        // Handle null/undefined and escape quotes
        const stringCell = (cell ?? '').toString();
        return `"${stringCell.replace(/"/g, '""')}"`;
    }).join(',')).join('\n');

    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.setAttribute('download', `tour-data-${new Date().toISOString().split('T')[0]}.csv`);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}
</script>
<script>
// Firebase SDK (Added these script tags to the head in the final code)
// This block is now integrated into the main script

</script>
</body>
</html>